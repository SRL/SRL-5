(*
Gametab
=======

This Include contains all Gametab Routines.

.. contents::

*)

type
  TSMSetting = (Stereo, Mono, NoChange);

{ const LobbyTab Constants;
  Description: Constants representing lobbytab numbers. }

const
  L_PlayerInfo = 1;
  L_WorldSelect = 2;
  L_FriendsList = 3;
  L_FriendsChat = 4;
  L_ClanChat = 5;
  L_Options = 6;

(*

Ability Book and Action Bar
---------------------------

Ability Book and Action Bar related functions

*)

(*
ActiveMainAbilityTab
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

      function ActiveMainAbilityTab(): Integer;

Returns which of the four main Ability Book tabs is currently active.

.. note::

    by euphemism

*)
function ActiveMainAbilityTab(): Integer;
var
  TabColor: Integer;
  TabColorArray: TIntegerArray;
begin
  SetLength(TabColorArray, 4);
  TabColorArray := [1996449, 2315049, 7225628, 2370692];
  TabColor := GetColor(551, 282);
  for Result := 0 to 3 do
    if (TabColor = TabColorArray[Result]) then
      Exit;
end;

(*
ActiveSubAbilityTab
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

      function ActiveSubAbilityTab(): Integer;

Returns which of the sub-tabs beneath the active main tab is currently active.

.. note::

    by euphemism

*)
function ActiveSubAbilityTab(): Integer;
var
  H, S, L: Extended;
  XVals: TIntegerArray;
begin
  SetLength(XVals, 4);
  XVals := [555, 601, 648, 695];
  if (ActiveMainAbilityTab = 0) then
    XVals[1] := 602;
  for Result := 0 to 3 do
  begin
    ColorToHSL(GetColor(XVals[Result], 262), H, S, L);
    if (L > 10) then
      Exit;
  end;
end;

(*
SetAbilityBook
~~~~~~~~~~~~~~

.. code-block:: pascal

      function SetAbilityBook(Tab: Integer): Boolean;

Takes a sub-tab constant (see globals.simba), and changes the main tab and
sub-tabs of the Ability Book as necessary to make the target sub-tab
the active sub-tab. Returns true if successful.

.. note::

    by euphemism

*)
function SetAbilityBook(Tab: Integer): Boolean;
var
  ActiveMain, I, TabCompare, TimeOut, X, Y: Integer;
  CompareFunc: Function(): Integer;
  BoxCoords, TabLocations, TabLoop: T2DIntegerArray;
begin
  if (not GameTab(TAB_MAGIC)) then
    Exit;
  SetLength(TabLocations, 4);
  TabLocations[0] := [AB_ATTACK, AB_STRENGTH]; //First dimension is main tab, second dimension is sub tab position.
  TabLocations[1] := [AB_RANGED];
  TabLocations[2] := [AB_ABILITIES, AB_COMBAT_SPELLS, AB_TELEPORT_SPELLS, AB_SKILLING_SPELLS];
  TabLocations[3] := [AB_DEFENSE, AB_CONSTITUTION];
  SetLength(BoxCoords, 2);
  BoxCoords[0] := [548, 205, 594, 237, 47]; //Main tab size and spacing
  BoxCoords[1] := [557, 248, 586, 277, 46]; //Sub tab size and spacing
  for X := 0 to 3 do //Converts tab constant into X Y pair, where X is the main tab, and Y is the sub tab.
  begin
    for Y := 0 to High(TabLocations[X]) do
    begin
      if (TabLocations[X][Y] = Tab) then
      begin
        Result := True;
        Break;
      end;
    end;
    if (Result) then
      Break;
  end;
  ActiveMain := ActiveMainAbilityTab; //Stores the current active main tab to reduce redundancy.
  SetLength(TabLoop, 2);
  TabLoop[0] := [ActiveMain, X]; //Holds the active main tab, and the target main tab.
  TabLoop[1] := [ActiveSubAbilityTab, Y]; //Holds the active sub tab to 0, and the target sub tab.
  Result := ((TabLoop[0][0] = TabLoop[0][1]) and (TabLoop[1][0] = TabLoop[1][1]));
  if (Result) then
    Exit;
  Wait(Random(300));
  for I := 0 to 1 do //This loop sets the main tab and sub tab to to the target tab.
  begin
    if (I = 1) then
      TabLoop[i][0] := ActiveSubAbilityTab; //Updates the stored active sub tab to account for switching the main tab.
    if (TabLoop[i][0] <> TabLoop[i][1]) then
    begin
      MouseBox((BoxCoords[i][0] + (BoxCoords[i][4] * TabLoop[i][1])), BoxCoords[i][1], (BoxCoords[i][2] + (BoxCoords[i][4] * TabLoop[i][1])), BoxCoords[i][3], MOUSE_LEFT); //Clicks the target tab.
      TimeOut := (GetSystemTime + RandomRange(800, 1200)); //Sets timeout fail-safe.
      if (I = 0) then //Points the CompareFunc function to check either the active main tab or sub tab based on the value of the looping variable.
        CompareFunc := @ActiveMainAbilityTab
      else
        CompareFunc := @ActiveSubAbilityTab;
      while ((GetSystemTime < TimeOut) and (CompareFunc() <> TabLoop[i][1])) do //Fail-safe and state check for the tab.
        Wait(16);
    end;
    if (I = 0) then //Sets the TabCompare variable to either the active main tab or active sub tab based on the value of the looping variable.
      TabCompare := ActiveMainAbilityTab
    else
      TabCompare := ActiveSubAbilityTab;
    Result := (TabCompare <> TabLoop[i][1]); //If the tab failed to change to the target tab, function returns false and exit.
    if (Result) then
      Exit;
    if (I = 0) then //Determines whether to wait between setting the main tab and sub tab, or to check the final result.
      Wait(400 + Random(300))
    else
      Result := ((ActiveMainAbilityTab = TabLoop[0][1]) and (ActiveSubAbilityTab = TabLoop[1][1]));
  end;
end;

(*
GetAbilityLocation
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure GetAbilityLocation(AbilityConstant: Integer; out SubTab, PositionUnderTab: Integer);

Returns the sub-tab (Through SubTab of the Ability Book that the Ability
(AbilityConstant) is under, and then the position of the ability within the
SubTab (Through PositionUnderTab).

.. note::

    by euphemism
    Last modified: Jan. 31st, 2013 by euphemism

Example:

.. code-block:: pascal

    GetAbilityLocation(AB_SURGE, SubTab, PositionUnderTab);
    //SubTab would contain 3 (AB_ABILITIES), as that is the constant for the
    //Abilities sub-tab, and PositionUnderTab would contain 7, as that is the
    //position of the ability within the sub-tab.
*)
procedure GetAbilityLocation(AbilityConstant: Integer; out SubTab, PositionUnderTab: Integer);
var
  AbilityTabs: TIntegerArray;
begin
  AbilityTabs := [AB_ATTACK, AB_STRENGTH, AB_RANGED, AB_ABILITIES, AB_DEFENCE, AB_CONSTITUTION];
  SubTab := AbilityTabs[(AbilityConstant - 13) div 12];
  PositionUnderTab := ((AbilityConstant - 12) - (((AbilityConstant - 13) div 12) * 12));
end;

(*
AbilitySlotToBox
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function AbilitySlotToBox(Slot: Integer): TBox;

Returns a TBox around the specified Ability Book slot.  Currently does not work
with the standard combat spells tab, as they are aligned to a different grid
than the rest of the Ability Book.

.. note::

    by euphemism
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    SlotBox := AbilitySlotToBox(AB_SURGE);
    MouseBox(SlotBox.x1, SlotBox.y1, SlotBox.x2, SlotBox.y2, mouse_Left);
*)
function AbilitySlotToBox(Slot: Integer): TBox;
begin
  if not InRange(Slot, 1, 20) then
  begin
    srl_Warn('AbilitySlotToBox', 'Slot must be within 1-20!', warn_AllVersions);
    Exit;
  end;
  with Result do
  begin
    X1 := 561 + ((((Slot + 3) mod 4)) * 44);
    Y1 := 290 + ((((Slot - 1) div 4)) * 36);
    X2 := X1 + 29;
    Y2 := Y1 + 29;
  end;
end;

(*
IsActionBarOpen
~~~~~~~~~~~~~~~

.. code-block:: pascal

      function IsActionBarOpen(): Boolean;

Results True if the Action Bar is showing.

.. note::

    by euphemism

*)
function IsActionBarOpen(): Boolean;
var
  Color: Integer;
begin
  Color := GetColor(45, 283);
  Result := ((Color = 2697663) or (Color = 15790330));
end;

(*
ToggleActionBar
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ToggleActionBar(Open: Boolean): Boolean;

Opens or closes the Action Bar, true if had to toggle.

.. note::
    by euphemism, modelled after ToggleXPBarEx by Narcle & IceFire908

*)
function ToggleActionBar(Open: Boolean): Boolean;
var
  T: Integer;
begin
  if (Open xor IsActionBarOpen()) then
  begin
    if Open then
      MouseBox(499, 326, 516, 338, mouse_Left)
    else
      MouseBox(499, 264, 516, 277, mouse_Left);
    T := GetSystemTime + 300;
    repeat
      wait(RandomRange(10, 30));
      Result := (Open = IsActionBarOpen());
    until Result or (GetSystemTime > t);
  end else
    Result := true;
end;

(*
ActionBarSlotToBox
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ActionBarSlotToBox(Slot: Integer): TBox;

    Returns the TBox (30 x 30) of the action bar at position Slot.

.. note::

    by Slushpuppy

Example:

.. code-block:: pascal

    ActionBarSlotToBox(1);

*)
function ActionBarSlotToBox(Slot: Integer): TBox;
begin
  if InRange(Slot, 1, 12) then
  begin
    with Result do
    begin
      X1 := 47 + (Slot - 1) * 36;
      Y1 := 347 - SRL_NAVBAR_INGAME_Y;
      X2 := X1 + 29;
      Y2 := 376 - SRL_NAVBAR_INGAME_Y;
    end;
  end else
    srl_Warn('ActionBarSlotToBox', 'Slot must be within 1-12!', warn_AllVersions);
end;

(*
ActionBarSlotEmpty
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ActionBarSlotEmpty(Slot: Integer): Boolean;

Results True if the specified Action Bar slot is empty.

.. note::

    by euphemism
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    if (not ActionBarSlotEmpty(4)) then
      ClearActionBarSlot(4);
*)
function ActionBarSlotEmpty(Slot: Integer): Boolean;
var
  MidPoint: TPoint;
begin
  ToggleActionBar(True);
  MidPoint := MiddleBox(ActionBarSlotToBox(Slot));
  Result := (GetColor(MidPoint.x, MidPoint.y) = 59);
end;

(*
GetAbilityCooldown
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function GetAbilityCooldown(ActionBarSlotOrAbilityConstant: Integer): Integer;

Returns a number, 0-100 (or -1 in the case that it fails to get the cooldown)
indicating the percentage complete of the cooldown of the specified ability,
ActionBarSlotOrAbilityConstant.  Passing 1-12 will check the ability in the
coordinating Action Bar slot, and passing an ability constant, such as AB_SURGE,
will open the Ability Book and check there for the ability's cooldown.

.. note::

    by euphemism
    Last modified: Jan. 31st, 2013 by euphemism

Example:

.. code-block:: pascal


    if (GetAbilityCooldown(AB_SURGE) = 100) then
      WriteLn('Ability is ready to use.');

    while (GetAbilityCooldown(AB_SURGE) < 100) do
      WriteLn('Ability cooldown is ' + IntToStr(GetAbilityCooldown(AB_SURGE)) + '% complete.');
*)
function GetAbilityCooldown(ActionBarSlotOrAbilityConstant: Integer): Integer;
var
  ColorFix, ClientBitmap, I, Len, PositionUnderTab, SubTab, SumTotal, x1, y1, x2, y2, W, H: Integer;
  MidPoint: TPoint;
  AbilitySlot: TBox;
  PointCircle, Line, TPA: TPointArray;
begin
  Result := - 1;
  case (ActionBarSlotOrAbilityConstant) of
    1..12: AbilitySlot := ActionBarSlotToBox(ActionBarSlotOrAbilityConstant);
    AB_SLICE..AB_SINGLE_WAY_WILDERNESS:
    begin
      GetAbilityLocation(ActionBarSlotOrAbilityConstant, SubTab, PositionUnderTab);
      if (not SetAbilityBook(SubTab)) then
        Exit;
      AbilitySlot := AbilitySlotToBox(PositionUnderTab);
    end;
  end;
  try
    ClientBitmap := BitmapFromClient(AbilitySlot.x1, AbilitySlot.y1, AbilitySlot.x2, AbilitySlot.y2);
    SetBitmapName(ClientBitmap, 'CooldownBitmap');
    x1 := 0;
    y1 := 0;
    x2 := AbilitySlot.x2 - AbilitySlot.x1;
    y2 := AbilitySlot.y2 - AbilitySlot.y1;
    W := x2 + 1;
    H := y2 + 1;
    if (InRange(ActionBarSlotOrAbilityConstant, 1, 12)) then
    begin
      FindColors(TPA, 3111603, AbilitySlot.x1 + 2, AbilitySlot.y1 + 19, AbilitySlot.x1 + 8, AbilitySlot.y1 + 26);
      OffsetTPA(TPA, IntToPoint( - AbilitySlot.x1, - AbilitySlot.y1));
      for I := 0 to High(TPA) do
        FastSetPixel(ClientBitmap, TPA[i].x, TPA[i].y, 0);
    end;
    GetMufasaBitmap(ClientBitmap).Brightness(GetMufasaBitmap(ClientBitmap), 100);
    GetMufasaBitmap(ClientBitmap).Posterize(GetMufasaBitmap(ClientBitmap), 60);
    GetMufasaBitmap(ClientBitmap).Contrast(GetMufasaBitmap(ClientBitmap), 30);
    GetMufasaBitmap(ClientBitmap).Desaturate(GetMufasaBitmap(ClientBitmap));
    MidPoint := IntToPoint(15, 14);
    TPAFromCircleWrap(MidPoint.x, MidPoint.y, 14, PointCircle);
    SortCircleWise(PointCircle, MidPoint.x, MidPoint.y, 359, False, True);
    Len := Length(PointCircle);
    for I := 0 to (Len - 1) do
    begin
      if (InRange(I, 0, 38)) then
        MidPoint := IntToPoint(14, 15)
      else
        MidPoint := IntToPoint(15, 14);
      tmp_TPAFromLineWrap(Midpoint.x, MidPoint.y, PointCircle[i].x, PointCircle[i].y, Line) SortTPAFrom(Line, MidPoint);
      InvertTPA(Line);
      if (I = 0) then
        SetLength(Line, 7)
      else
        SetLength(Line, Length(Line) - 4);
      SumTotal := 0;
      SumTotal := SumIntegerArray(FastGetPixels(ClientBitmap, Line));
      if (SumTotal <> 0) then
      begin
        Result := Ceil((Round(FixD(Degrees(ArcTan2(PointCircle[i].x - MidPoint.x - 1, - (PointCircle[i].y - MidPoint.y))))) / 360.0) * 100) + 1;
        if (Result = 99) then
        begin
          ColorFix := GetColor(AbilitySlot.x1 + 14, AbilitySlot.y1 + 2);
          if ((ColorFix = 6706) or (ColorFix = 1710617)) then
            Result := 100;
        end;
        Break;
      end
      else if (I = (Len - 1)) then
        Result := 0;
    end;
  finally
    FreeBitmap(ClientBitmap);
  end;
end;

(*
UseAbility
~~~~~~~~~~

.. code-block:: pascal

    function UseAbility(ActionBarSlotOrAbilityConstant: Integer): Boolean;

If the ability is ready to use, the function will click the ability and return
true or false depending on if the cooldown of the ability begins.  Passing 1-12
will use the ability in the coordinating Action Bar slot, and passing an ability
constant, such as AB_SURGE, will open the Ability Book and use the ability there.

.. note::

    by euphemism
    Last modified: Jan. 31st, 2013 by euphemism

Example:

.. code-block:: pascal


    if (not UseAbility(3)) then
      WriteLn('Was unable to use ability in Action Bar slot 3.');
*)
function UseAbility(ActionBarSlotOrAbilityConstant: Integer): Boolean;
var
  PositionUnderTab, SubTab, TimeMarker: Integer;
  AbilitySlot: TBox;
begin
  Result := False;
  case (ActionBarSlotOrAbilityConstant) of
    1..12:
      begin
        AbilitySlot := ActionBarSlotToBox(ActionBarSlotOrAbilityConstant);
        if (ActionBarSlotEmpty(ActionBarSlotOrAbilityConstant)) then
          Exit;
      end;
    AB_SLICE..AB_SINGLE_WAY_WILDERNESS:
      begin
        GetAbilityLocation(ActionBarSlotOrAbilityConstant, SubTab, PositionUnderTab);
        if (not SetAbilityBook(SubTab)) then
          Exit;
        AbilitySlot := AbilitySlotToBox(PositionUnderTab);
      end;
  end;
  if (not (GetAbilityCoolDown(ActionBarSlotOrAbilityConstant) = 100)) then
    Exit;
  MouseTBox(AbilitySlot, mouse_left);
  TimeMarker := GetSystemTime + RandomRange(800, 1204);
  repeat
    Result := (GetAbilityCoolDown(ActionBarSlotOrAbilityConstant) <> 100);
  until ((Result) or (GetSystemTime > TimeMarker));
end;

(*
AbilityInSlot
~~~~~~~~~~~~~

.. code-block:: pascal

    function AbilityInSlot(AbilityConstant, ActionBarSlot: Integer): Boolean;

Opens up the Ability Book where the ability, AbilityConstant, is located, and
checks to see if the ability is in the specified Action Bar slot, ActionBarSlot.
This function doesn't really have a use except for within the following functions.

.. note::

    by euphemism
    Last modified: Jan. 31st, 2013 by euphemism
*)
function AbilityInSlot(AbilityConstant, ActionBarSlot: Integer): Boolean;
var
  bmp, PositionUnderTab, SubTab, X, Y: Integer;
  Acc: Extended;
  Colors: TIntegerArray;
  TPA: TPointArray;
  AbilitySlot, ActionSlot: TBox;

begin
  Result := False;
  GetAbilityLocation(AbilityConstant, SubTab, PositionUnderTab);
  if (not SetAbilityBook(SubTab)) then
    Exit;
  AbilitySlot := AbilitySlotToBox(PositionUnderTab);
  ActionSlot := ActionBarSlotToBox(ActionBarSlot);
  TPAFromBoxWrap(IntToBox(AbilitySlot.x1 + 8, AbilitySlot.y1 + 7, AbilitySlot.x2 - 7, AbilitySlot.y2 - 8), TPA);
  FilterPointsPie(TPA, 0, ((GetAbilityCoolDown(AbilityConstant) * 360) / 100) - 1, 0, 7, AbilitySlot.x1 + 15, AbilitySlot.y1 + 14);
  GetColorsWrap(TPA, Colors);
  OffsetTPA(TPA, IntToPoint(- (AbilitySlot.x1 + 8), - (AbilitySlot.y1 + 7)));
  try
    Bmp := BitmapFromString(15, 15, '');
    FastSetPixels(bmp, TPA, Colors);
    Result := FindDeformedBitmapToleranceIn(Bmp, X, Y, ActionSlot.x1 + 8, ActionSlot.y1 + 7, ActionSlot.x2 - 7, ActionSlot.y2 - 8, 0, 0, False, Acc);
  finally
    FreeBitmap(Bmp);
  end;
end;

(*
GetAdrenalinePercent
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function GetAdrenalinePercent : Integer;

Gets percent(0-100) of adrenaline in the action bar. Function returns -1 if actionbar is not active


.. note::

    by Slushpuppy

Example:

.. code-block:: pascal

    GetAdrenalinePercent;

*)
function GetAdrenalinePercent(): Integer;
var
  BarX1,BarX2,BarY1,BarY2 : Integer;
  tpa : TPointArray;
  box : TBox;
begin
  Result := -1;
  if isActionBarOpen then
  begin
    Result := 100;
    BarY1 := 334 - SRL_NAVBAR_INGAME_Y;
    BarY2 := 337- SRL_NAVBAR_INGAME_Y;
    BarX1 := 49 - SRL_NAVBAR_INGAME_X;
    BarX2 := 469 - SRL_NAVBAR_INGAME_X;
    if FindColorsTolerance(tpa,1776411,BarX1,BarY1,BarX2,BarY2,15) then
    begin
      box := GetTPABounds(tpa);
      Result := Floor(100 - ((BarX2 - box.X1)*1.0 / (BarX2-BarX1) * 1.0) * 100);
    end;
   end;
end;

(*
IsActionBarLocked
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function IsActionBarLocked(): Boolean;

Results True if the Action Bar is locked.

.. note::

    by euphemism
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    if (IsActionBarLocked()) then
      ToggleActionBarLock(False);
*)
function IsActionBarLocked(): Boolean;
var
  Color: Integer;
begin
  Color := GetColor(19, 296);
  Result := ((Color = 5145251) or (Color = 8846590));
end;

(*
ToggleActionBarLock
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ToggleActionBarLock(Lock: Boolean): Boolean;

Locks or unlocks the Action Bar, true if had to toggle.

.. note::
    by euphemism, modelled after ToggleXPBarEx by Narcle & IceFire908
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    if (IsActionBarLocked()) then
      ToggleActionBarLock(False);
*)
function ToggleActionBarLock(Lock: Boolean): Boolean;
var
  T: Integer;
begin
  if (Lock xor IsActionBarLocked()) then
  begin
    MouseBox(10, 285, 34, 308, mouse_Left);
    T := GetSystemTime + RandomRange(1900, 2300);
    repeat
      wait(RandomRange(10, 30));
      Result := (Lock = IsActionBarLocked());
    until Result or (GetSystemTime > T);
  end else
    Result := true;
end;

(*
ActionBarEmpty
~~~~~~~~~~~~~~

.. code-block:: pascal

    function ActionBarEmpty(): Boolean;

Results True if the entire Action Bar slot is empty.

.. note::

    by euphemism
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    if (ActionBarEmpty()) then
      Writeln('Action Bar is empty and ready to receive abilities.');
*)
function ActionBarEmpty(): Boolean;
var
  I: Integer;
begin
  Result:= False;
  for I:= 1 to 12 do
    if (not ActionBarSlotEmpty(I)) then
      Exit;
  Result:= True;
end;

(*
ClearActionBarSlot
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ClearActionBarSlot(Slot: Integer): Boolean;

Results True if the specified Action Bar slot is successfully cleared.

.. note::

    by euphemism
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    if (ClearActionBarSlot(4)) then
      Writeln('Action Bar Slot 4 is now empty.');
*)
function ClearActionBarSlot(Slot: Integer): Boolean;
var
  SlotBox: TBox;
begin
  Result := ActionBarSlotEmpty(Slot);
  if (Result) then
    Exit;
  if (isActionBarLocked()) then
    ToggleActionBarLock(False);
  Wait(RandomRange(314, 504));
  SlotBox := ActionBarSlotToBox(Slot);
  DragMouse(SlotBox.x1, SlotBox.y1, 29, 27, 10, 310, 24, 23);
  Wait(RandomRange(100, 300));
  Result := ActionBarSlotEmpty(Slot);
end;

(*
ClearActionBar
~~~~~~~~~~~~~~

.. code-block:: pascal

    function ClearActionBar(): Boolean;

Results True if the entire Action Bar is successfully cleared.

.. note::

    by euphemism
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    if (ClearActionBar()) then
      Writeln('Action Bar is empty and ready to add abilities/prayers/items');
*)
function ClearActionBar(): Boolean;
var
  TimeMarker: Integer;
begin
  Result := ActionBarEmpty();
  if (Result) then
    Exit;
  MouseBox(10, 310, 34, 333, mouse_Right);
  if (not WaitOptionMulti(['Clear', 'all', 'r-a', 'ear', 'ar'], RandomRange(1504, 2306))) then
    Exit;

  TimeMarker:= GetSystemTime + RandomRange(1507, 2030);
  repeat
    Result := ActionBarEmpty();
  until (Result or (GetSystemTime > TimeMarker));
end;

(*
CurrentActionBar
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function CurrentActionBar(): Integer;

Members can have five different Action Bars setup.  Returns the number of the
active Action Bar.  Returns -1 if it is unable to grab the text.

.. note::

    by euphemism
    Last modified: Dec. 21st, 2012 by euphemism

Example:

.. code-block:: pascal

    if (CurrentActionBar() <> 1) then
      SwitchActionBar(1, False);
*)
function CurrentActionBar(): Integer;
begin
  Result := StrToIntDef(GetTextAtExWrap(495, 304, 501, 313, 0, 0, 0, 3111603, 0, 'UpChars'), -1);
end;

(*
SwitchActionBar
~~~~~~~~~~~~~~~

.. code-block:: pascal

      function SwitchActionBar(WhichBar: Integer; UseBindKey: Boolean): Boolean;

Switch to action bar WhichBar, returns true on success.
Set and use ctrl bind key if UseBindKey,
otherwise click the arrows or right click to switch.

.. note::

    by riwu

*)
function SwitchActionBar(WhichBar: Integer; UseBindKey: Boolean): Boolean;
var
  currentBar, r, i, diff, tWait: Integer;
  ClickForward: Boolean;
  Keys: TIntegerArray;
  Arg: TVariantArray;
begin
  Result:= False;

  if Length(Players) > 0 then
    if not Players[CurrentPlayer].Member then
    begin
      srl_Warn('SwitchBar', 'F2P cannot switch action bar!', warn_AllVersions);
      Exit;
    end;

  if not InRange(WhichBar, 1, 5) then
  begin
    srl_Warn('SwitchBar', 'WhichBar must be within 1-5!', warn_AllVersions);
    Exit;
  end;

  currentBar:= CurrentActionBar();
  Result:= (WhichBar = currentBar);
  if Result then
    Exit;

  if UseBindKey then
  begin
    if Length(Players) < 1 then
      NumberOfPlayers(1);

    if not Players[CurrentPlayer].ActionBarSet then
    begin
      MouseBox(492, 300, 507, 314, mouse_Right);
      if WaitOptionMulti(['Custo', 'mise', 'Modi', 'Key'], 618) then
      begin
        Arg:= ['press']
        WaitFuncEx('FindBlackChatMessage', Arg, RandomRange(10, 50), RandomRange(618, 777));
        TypeByte(VK_CONTROL);
        wait(RandomRange(122, 244));
        Players[CurrentPlayer].ActionBarSet:= True;
      end;
    end;

    Keys:= [VK_CONTROL, VK_0 + WhichBar];
    for i:=0 to High(Keys) do
    begin
      KeyDown(Keys[i]);
      wait(RandomRange(10, 200 - i * 100));
    end;

    r:= Random(2);
    KeyUp(Keys[r]);
    wait(Random(60));
    KeyUp(Keys[iAbs(r - 1)]);
  end else
  begin
    diff:= iAbs(currentBar - WhichBar);
    if InRange(diff, 2, 3) then
    begin
      MouseBox(492, 300, 507, 314, mouse_Right);
      WaitOption(ToStr(WhichBar), 618);
    end else
    begin
      ClickForward:= (currentBar < WhichBar) xor (diff > 2);

      if ClickForward then
        MouseBox(493, 318, 502, 327, mouse_Left)
      else
        MouseBox(493, 288, 502, 297, mouse_Left)
    end;
  end;

  tWait:= GetSystemTime + RandomRange(3000, 4000);
  while (tWait > GetSystemTime) do
  begin
    Result:= (WhichBar = CurrentActionBar);
    if Result then
      Exit;
  end;
end;

(*
ClickActionBarSlot
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ClickActionBarSlot(Slot: Integer): Boolean;

Clicks the specified Action Bar slot.  If the specified Action Bar slot is empty
the function will return false.  Otherwise, it clicks the slot and returns true.

.. note::

    by euphemism
    Last modified: Jan. 31st, 2013 by euphemism
*)
function ClickActionBarSlot(Slot: Integer): Boolean;
var
  SlotBox: TBox;
begin
  Result := False;
  if (ActionBarSlotEmpty(Slot)) then
    Exit;
  SlotBox := ActionBarSlotToBox(Slot);
  MouseTBox(SlotBox, mouse_left);
  Result := True;
end;

(*
AddAbilityToActionBar
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function AddAbilityToActionBar(AbilityConstant, ActionBarSlot: Integer): Boolean;

Adds the specified ability, AbilityConstant, from the Ability Book to the
specified slot, ActionBarSlot, of the Action Bar.  Returns true on success.

.. note::

    by euphemism
    Last modified: Jan. 31st, 2013 by euphemism

Example:

.. code-block:: pascal


    if (AddAbilityToActionBar(AB_SURGE, 5)) then
      WriteLn('Added the Surge ability to Action Bar slot 5.');
*)
function AddAbilityToActionBar(AbilityConstant, ActionBarSlot: Integer): Boolean;
var
  PositionUnderTab, SubTab, TimeMarker: Integer;
  AbilitySlot, ActionSlot: TBox;
begin
  Result := AbilityInSlot(AbilityConstant, ActionBarSlot);
  if (Result) then
    Exit;
  GetAbilityLocation(AbilityConstant, SubTab, PositionUnderTab);
  AbilitySlot := AbilitySlotToBox(PositionUnderTab);
  ActionSlot := ActionBarSlotToBox(ActionBarSlot);
  DragMouse(AbilitySlot.x1, AbilitySlot.y1, 29, 29, ActionSlot.x1, ActionSlot.y1, 28, 28);
  TimeMarker := GetSystemTime + RandomRange(802, 1113);
  repeat
    Result := AbilityInSlot(AbilityConstant, ActionBarSlot);
    Wait(12);
  until ((Result) or (GetSystemTime > TimeMarker));
  TimeMarker := GetSystemTime + RandomRange(1004, 1516);
  if (Result) then
    repeat
      if (GetColor(ActionSlot.x1 - 2, ActionSlot.y1 - 2) <> 13158600) then
        Exit;
    until (GetSystemTime > TimeMarker);
end;

function ExistsItem(I: Integer): Boolean; forward;

(*
AddItemToActionBar
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function AddItemToActionBar(InvSlot, ActionBarSlot: Integer): Boolean;

Adds the item (if it exists) in the specified Inventory slot, InvSlot, to the
specified slot, ActionBarSlot, of the Action Bar.  Returns true on success.

.. note::

    by euphemism
    Last modified: Jan. 31st, 2013 by euphemism

Example:

.. code-block:: pascal


    if (AddItemToActionBar(4, 5)) then
      WriteLn('Added the item in Inventory slot 4 to Action Bar slot 5.');
*)
function AddItemToActionBar(InvSlot, ActionBarSlot: Integer): Boolean;
var
  bmp, I, Len, TimeMarker, X, Y: Integer;
  acc: Extended;
  InventoryBox, ActionSlot: TBox;
  KeyBindTPA, TPA: TPointArray;
begin
  Result := False;
  if ((not GameTab(tab_Inv)) or (not ToggleActionBar(True))) then
    Exit;
  if (not ExistsItem(InvSlot)) then
    Exit;
  InventoryBox := InvBox(InvSlot);
  InventoryBox.x2 := InventoryBox.x2 - 2;
  InventoryBox.y2 := InventoryBox.y2 - 2;
  ActionSlot := ActionBarSlotToBox(ActionBarSlot);
  try
    bmp := BitmapFromClient(InventoryBox.x1, InventoryBox.y1, InventoryBox.x2, InventoryBox.y2);
    TPAFromBoxWrap(IntToBox(InventoryBox.x1 + 2, InventoryBox.y2 - 10, InventoryBox.x1 + 8, InventoryBox.y2 - 3), KeyBindTPA);
    OffsetTPA(KeyBindTPA, IntToPoint(- InventoryBox.x1, - InventoryBox.y1));
    Len := Length(KeyBindTPA);
    for I := 0 to (Len - 1) do
      FastSetPixel(bmp, KeyBindTPA[i].x, KeyBindTPA[i].y, 0);
    ColorToleranceSpeed(0);
    FindColorsTolerance(TPA, 3292227, InventoryBox.x1, InventoryBox.y1, InventoryBox.x2, InventoryBox.y2, 8);
    OffsetTPA(TPA, IntToPoint(- InventoryBox.x1, - InventoryBox.y1));
    Len := Length(TPA);
    for I := 0 to (Len - 1) do
      FastSetPixel(bmp, TPA[i].x, TPA[i].y, 0);
    FindDeformedBitmapToleranceIn(bmp, X, Y, ActionSlot.x1, ActionSlot.y1 - 1, ActionSlot.x2, ActionSlot.y2, 35, 0, false, acc);
    Result := (acc > 0.8);
    if (Result) then
      Exit;
    DragMouse(InventoryBox.x1, InventoryBox.y1, 30, 30, ActionSlot.x1, ActionSlot.y1, 28, 28);
    TimeMarker := GetSystemTime + RandomRange(802, 1113);
    repeat
      if (ExistsItem(InvSlot)) then
      begin
        FindDeformedBitmapToleranceIn(bmp, X, Y, ActionSlot.x1, ActionSlot.y1 - 1, ActionSlot.x2, ActionSlot.y2 + 1, 35, 0, False, Acc);
        Result := (acc > 0.8);
      end;
    until ((Result) or (GetSystemTime > TimeMarker));
  finally
    FreeBitmap(bmp);
  end;
end;

(*
GetKeyBind
~~~~~~~~~~

.. code-block:: pascal

      function GetKeyBind(Slot: Integer): String;

Gets the key binded to the action bar at Slot.

.. note::

    by riwu
    Last modified: 1 Jan 2012 by riwu

*)
function GetKeyBind(Slot: Integer): String;
begin
  if not InRange(Slot, 1, 12) then
  begin
    srl_Warn('GetKeyBind', 'Slot must be within 1-12!', warn_AllVersions);
    Exit;
  end;

  if not IsActionBarOpen then
    if ToggleActionBar(True) then
      srl_Warn('GetKeyBind', 'Action bar opened to grab text', warn_AllVersions)
    else
    begin
      srl_Warn('GetKeyBind', 'Unable to open action bar', warn_AllVersions);
      Exit;
    end;

  Result:= GetTextAt(13 + 36 * Slot, 316, 0, 0, 0, 3111603, 0, 1, UpChars);
end;

(*
Gametab Functions
-----------------

*)

(*
GetCurrentTab
~~~~~~~~~~~~~

.. code-block:: pascal

    function GetCurrentTab: Integer;

Returns current tab.

.. note::

    by Zephyrsfury

Example:

.. code-block:: pascal

    if (not tabExists(TAB_MAGIC)) then
      writeln('We may be in a random event!');


*)
function GetCurrentTab: Integer;
var
  tP: TPoint;
begin
  Result := -1;
  if (not LoggedIn) then exit;

  for Result := 0 to (tab_LogOut - tab_Combat)-1 do
  begin
    tP.X := 535 + Result mod 8 * 30;
    tP.Y := 169 + Result div 8 * 298;
    if (GetColor(tP.X, tP.Y) = 3775717) then //Midpoint of the top boundary of the tab
      Break;
  end;
  Result := Result + tab_Combat;
  if BankScreen then
    Result := tab_Inv;
end;

(*
TabExists
~~~~~~~~~

.. code-block:: pascal

    function TabExists(tab: integer): boolean;

Returns true if the gametab 'tab' exists.  Tab constants can be found in
globals.simba.

.. note::

    by Zephyrsfury & Icefire908
    Last Modified: Mar. 7th, 2012 by Coh3n

Example:

.. code-block:: pascal

    if (not tabExists(TAB_MAGIC)) then
      writeln('We may be in a random event!');
*)
function TabExists(tab: integer): boolean;
var
  b: TBox;
  tmpCTS: integer;
begin
  result := false;
  if (not loggedIn) then
    exit;

  if (not inRange(tab, TAB_COMBAT, TAB_LOGOUT)) then
  begin
    SRL_Warn('TabExists', 'Tab ' + toStr(Tab) + ' is not a valid tab number.', warn_AllVersions);
    exit;
  end;

  // requires CTS 1, may result in false negatives if CTS 2
  tmpCTS := getColorToleranceSpeed;
  colorToleranceSpeed(1);

  if (tab = TAB_INV) then
    if (bankScreen) then
    begin
      colorToleranceSpeed(tmpCTS);
      result := true;
      exit;
    end;

  if (tab = TAB_LOGOUT) then
  begin
    result := (getColor(746, 0) = 0); //Top left of tab_LogOut
    colorToleranceSpeed(tmpCTS);
    exit;
  end;

  // small boxes inside the tabs (hardly any of the background showing)
  b := gridBox(tab - 20, 8, 2, 13, 18, 30, 300, point(536, 186));

  // the color of the tab background
  result := (countColorTolerance(5005422, b.x1, b.y1, b.x2, b.y2, 55) < 250); // actual count should be 266

  colorToleranceSpeed(tmpCTS);
end;

(*

GameTab
~~~~~~~

.. code-block:: pascal

    function GameTab(Tab: Integer): Boolean;

Returns True if the Tab exists.

.. note::

    by Zephyrsfury

.. code-block:: pascal

    const
      tab_Combat = 21;
      tab_Stats = 22;
      tab_Quest = 23;
      tab_Diary = 24;
      tab_Inv = 25;
      tab_Equip = 26;
      tab_Prayer = 27;
      tab_Magic = 28;
      tab_Objectives = 29;
      tab_Friends = 30;
      tab_Ignore = 31;
      tab_Clan = 32;
      tab_Options = 33;
      tab_Emotes = 34;
      tab_Music = 35;
      tab_Notes = 36;
      tab_LogOut = 37;

.. note::
    Please use the constants and not the numbers! They may change any interface update.


Example:

.. code-block:: pascal

*)
function GameTab(Tab: Integer): Boolean;
var
  tP: TPoint;
  T, Tries: Integer;

begin
  if (not LoggedIn) then
    Exit;

  Result := false;
  if (not(InRange(Tab, Tab_Combat, Tab_LogOut))) then
  begin
    SRL_Warn('GameTab', 'Tab ' + IntToStr(Tab) + ' is not a valid tab number.', warn_AllVersions);
    Exit;
  end;

  Result := (GetCurrentTab = Tab);
  if (Result) then exit;

  if (TabExists(Tab)) then
  begin
    tP := Point((Tab - 21) mod 8 * 30 + RandomRange(527, 545),
      (Tab - 21) div 8 * 298 + RandomRange(177, 197));
    if (Tab = tab_LogOut) then
      tP := Point(RandomRange(747, 760), RandomRange(3, 18));

    Tries := 0;
    while ((Tries < 3) and (not Result)) do
    begin
      Mouse(tP.X, tP.Y, 0, 0, mouse_left);

      T := GetSystemTime;
      while (not Result) and (GetSystemTime - T < 2000) do
      begin
        Result := (GetCurrentTab = Tab);
        Wait(100 + Random(100));
      end;

      Inc(Tries);
    end;

    if (Result) then
      Wait(250 + Random(300));

  end else
    SRL_Warn('GameTab', 'GameTab ' + IntToStr(Tab) + ' is not a valid tab number.', warn_Notice);
end;

(*

FTab
~~~~

.. code-block:: pascal

    function FTab(Tab: Integer): Boolean;

Instead of clicking the Tab this uses the F keys to instantly switch to the tab.
Only works with Inv, Equip, Prayer, Magic and Combat tabs (F1-F5).
Returns True if the Tab exists.

.. note::

    by Narcle
    Last Modified: 22/12/12 by riwu

.. code-block:: pascal

    const
      tab_Combat = 21;
      tab_Inv = 25;
      tab_Equip = 26;
      tab_Prayer = 27;
      tab_Magic = 28;

.. note::
    Please use the constants and not the numbers! They may change any interface update.


Example:

.. code-block:: pascal

*)
function FTab(Tab: integer): boolean;
var
  T, F: integer;
begin
  if (GetCurrentTab = Tab) then
  begin
    result := true;
    Exit;
  end;

  Case Tab of
    tab_Inv: F := 1;
    tab_Equip: F := 2;
    tab_Prayer: F := 3;
    tab_Magic: F := 4;
    tab_Combat: F := 5;
    else
      writeln('Tab '+inttostr(tab)+' isn''t a valid option.');
  end;
  T := GetSystemTime + 618;
  Repeat
    TypeByte(111+F);
    Wait(150+random(100));
    Result := GetCurrentTab = Tab;
  until Result or (GetSystemTime > T);

  if not Result then      //F keys sometimes doesn't work properly in EOC, may be a bug on Jagex's part though
    Result:= GameTab(Tab);   //nevertheless this is a good failsafe
end;

(*

Gametab 1
---------

Gametab 1 related functions.
*)

(*

SetFightMode
~~~~~~~~~~~~

.. code-block:: pascal

    function SetFightMode(oFightMode: Integer): Boolean;

Sets fight mode.  Returns false if failed to set desired mode.

.. note::

    by Nielsie95 & Nava2, fixed by Quickmarch

Example:

.. code-block:: pascal

*)
function SetFightMode(oFightMode: Integer): Boolean;
var
  i, x, y: Integer;
  b: TBox;
  cmbBoxes: TBoxArray;
begin
  Result := False;
  if not(Loggedin)then Exit;
  GameTab(tab_Combat);
  Wait(200 + Random(100));

  cmbBoxes := [IntToBox(575, 255, 630, 290), IntToBox(660, 255, 710, 290),
               IntToBox(575, 310, 630, 345), IntToBox(660, 310, 710, 345)];
  b := cmbBoxes[oFightMode - 1];

  if (oFightMode = 4) and (not FindColor(x, y, 2070783, 660, 310, 710, 345)) then
    b := cmbBoxes[2];

  i := 0;
  while (i < 4) do
  begin
    Result := FindColorTolerance(x, y, 1323362, b.x1, b.y1, b.x2, b.y2, 2);
    if (Result) then Exit;
    MouseBox(b.x1, b.y1, b.x2, b.y2, mouse_left);
    Wait(500 + Random(300));
    Inc(i);
  end;
end;

(*

GetWeaponName
~~~~~~~~~~~~~

.. code-block:: pascal

    Function GetWeaponName: String;

Returns the name of the weapon your currently using.

.. note::

    by Narcle

Example:

.. code-block:: pascal

*)
Function GetWeaponName: String;
begin
  if GameTab(tab_Combat) then
    Result := GetTextAtExWrap(584, 208, 734, 226, 0, 3, 4, 3907053, 0, UpChars);
end;

(*

GetWeaponData
~~~~~~~~~~~~~

.. code-block:: pascal

    function GetWeaponData(var WArr: array of TStringArray): Boolean;

Grabs weapon data and puts it into T2DStringArray.  The data is the
information you get when you mouse over the attack styles of the weapon.  This
then sets it into a array that can be used to set the fight mode of the weapon.
It even gets info like 'Crush' or 'Slash' can be useful if the NPC is weak to
that type of attack.

.. note::

    by Narcle

Example:

.. code-block:: pascal

*)
function GetWeaponData(var WArr: array of TStringArray): Boolean;
var
  x, y, i, ii, H, L: integer;
  TB: TBox;
  TP: TPointArray;
  T: TPoint;
begin
  Result := False;
  if (not LoggedIn) then
    Exit;
  if not GameTab(tab_Combat) then
    Exit;
  for i := 0 to 3 do
  begin
    T := Point(680-(i+1) mod 2*85, 270+2 mod (i+1)*28);
    if CountColor(2070783, T.x - 27, T.y-18, T.x + 40, T.y + 22) > 10 then
      Inc(L);
  end;
  SetArrayLength(WArr, L);
  for I := 0 to L-1 do
  begin
    MMouse(680-(i+1) mod 2*85, 270+2 mod (i+1)*28, 12, 12);
    wait(100+random(50));
    WaitFindColor(X, Y, 15133931, MIX1-10, MIY1-10, MIX2+10, MIY2+10, 0, 3000);
    GetClientDimensions(TB.X2, TB.Y2);
    TB := IntToBox(0, 0, TB.X2, TB.Y2);
    FindColors(TP, 15133931, TB.X1, TB.Y1, TB.X2 - 1, TB.Y2 - 1);
    if (Length(TP) < 1) then
      Continue;
    TB := GetTPABounds(TP);
    H := ((TB.y2-TB.y1) div 17)-1;
    SetArrayLength(WArr[i], H+1);
    for ii := 0 to H do
    begin
      WArr[i][ii] := GetTextAtExWrap(TB.x1+1, TB.y1+2, TB.x2, TB.y1+18, 0, 3, 4, 4305653, 0, smallChars);
      Debugln(WArr[i][ii]);
      Result := (WArr[i][ii] <> '');
      IncEx(TB.Y1, 16);
    end;
  end;
end;

(*

SetWeaponMode
~~~~~~~~~~~~~

.. code-block:: pascal

    Function SetWeaponMode(Skill: string; WeaponData: array of TStringArray; SetIt: boolean): boolean;

Sets Combat mode depending on WeaponData given.  You can also
decide to SetIt which will set it to that particular skill or read it to see
if they are ranging, meleeing or using magic (with staff).

.. note::

    by Narcle

Example:

.. code-block:: pascal

*)
Function SetWeaponMode(Skill: string; WeaponData: array of TStringArray; SetIt: boolean): boolean;
var
  i, ii: integer;
begin
  for i := 0 to High(WeaponData) do
   for ii := 0 to High(WeaponData[i]) do
   if (Pos(Lowercase(skill), Lowercase(WeaponData[i][ii])) <> 0) then
   begin
     if SetIt then
       Result := SetFightMode(i + 1)
     else
       Result := True;
     Exit;
   end;
end;

(*

SetCombatType
~~~~~~~~~~~~~

.. code-block:: pascal

    function SetCombatType(Kind : string): Boolean;

Sets Combat mode inputted into Kind, treat like UpText.

.. note::

    by Narcle & Nava2

Example:

.. code-block:: pascal

*)
function SetCombatType(Skill: string): Boolean;
var
  WeapArr: array of TStringArray;
begin
  if GetWeaponData(WeapArr) then
    Result := SetWeaponMode(Skill, WeapArr, true)
  else
    Result := False;
end;

(*

GetCombatLevel
~~~~~~~~~~~~~~

.. code-block:: pascal

    function GetCombatLevel: Integer;

Returns the players combat level.

.. note::

    by Nielsie95 & Narcle
    Updated 26/11/2012 by riwu

Example:

.. code-block:: pascal

*)
function GetCombatLevel: Integer;
begin
  Result := -1;
  if not FTab(tab_Combat) then
    exit;

  Result := StrToIntDef(ExtractFromStr(GetTextAtExWrap(556, 316, 584, 333, 0,
                                    3, 4, 3111603, 0, UpChars), Numbers), -1);
end;

(*

HasTarget
~~~~~~~~~

.. code-block:: pascal

    function HasTarget: Boolean;

Returns true if the player has a combat target currently.

.. note::

    by riwu

Example:

.. code-block:: pascal

*)
function HasTarget: Boolean;
begin
  Result := False;
  if not FTab(tab_Combat) then
    Exit;

  Result := not FindTextTPA(3111603, 0, 615, 220, 654, 229, 'Target', UpChars, nothing);
end;

(*

GetTargetCombatLevel
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function GetTargetCombatLevel: Integer;

Returns the target combat level.

.. note::

    by riwu, modelled after GetCombatLevel by Nielsie95 & Narcle

Example:

.. code-block:: pascal

*)
function GetTargetCombatLevel: Integer;
begin
  Result := -1;
  if not (FTab(tab_Combat) and HasTarget) then
  begin
    srl_Warn('GetTargetCombatLevel', 'Could not get target level', warn_AllVersions);
    Exit;
  end;

  Result := StrToIntDef(ExtractFromStr(GetTextAtExWrap(695, 208, 728, 223, 0,
                                    3, 4, 3111603, 0, UpChars), Numbers), -1);
end;

(*
TargetHpPercent
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TargetHpPercent: Integer;

    Returns the Hp Percent of the target.

.. note::

    by riwu

Example:

.. code-block:: pascal

*)
function TargetHpPercent: Integer;
var
  hpBar: TPointArray;
  box: TBox;
begin
  Result:= 0;

  if not FTab(tab_Combat) then
  begin
    srl_Warn('TargetHpPercent', 'Could not open combat tab', warn_AllVersions);
    Exit;
  end;

  if not HasTarget then
    Exit;

  if FindColorsTolerance(hpBar, 2329176, 600, 237, 685, 242, 50) then
  begin
    box:= GetTPABounds(hpBar);
    Result:= Round((box.X2 - box.X1 + 1) / 0.86);
  end;
end;

(*

Retaliate
~~~~~~~~~

.. code-block:: pascal

    procedure Retaliate(RetTrue: Boolean);

Set's Auto Retaliate ON of OFF.

.. note::

    by WT-Fakawi & n3ss3s, slight mod by EvilChicken!
    Updated 26/11/2012 by riwu

Example:

.. code-block:: pascal

*)
procedure Retaliate(RetTrue: Boolean);
begin
  if not FTab(tab_Combat) then
    Exit;

  if (RetTrue) xor FindTextTPA(3111603, 0, 558, 437, 682, 455, 'On', UpChars, nothing) then
    MouseBox(558, 437, 682, 455, mouse_left);
end;

(* 

Gametab 2
---------

Gametab 2 related functions.

*)

//****************************************************************************//
// * GameTab 2 Related Functions.
//****************************************************************************//

{ const Skill Constants;
  Description: Constants representing player skills. }
{ consts in Players.scar ; Here is the list for easier access
const
  SKILL_ATTACK        = 0;
  SKILL_DEFENCE       = 1;
  SKILL_STRENGTH      = 2;
  SKILL_HITPOINTS     = 3;    
  SKILL_RANGE         = 4;
  SKILL_PRAYER        = 5;
  SKILL_MAGIC         = 6;
  SKILL_COOKING       = 7;
  SKILL_WOODCUTTING   = 8;
  SKILL_FLETCHING     = 9;
  SKILL_FISHING       = 10;
  SKILL_FIREMAKING    = 11;
  SKILL_CRAFTING      = 12;
  SKILL_SMITHING      = 13;
  SKILL_MINING        = 14;
  SKILL_HERBLORE      = 15;
  SKILL_AGILITY       = 16;
  SKILL_THIEVING      = 17;
  SKILL_SLAYER        = 18;
  SKILL_FARMING       = 19;
  SKILL_RUNECRAFTING  = 20;
  SKILL_HUNTER        = 21;
  SKILL_CONSTRUCTION  = 22;
  SKILL_SUMMONING     = 23;
  SKILL_DUNGEONEERING = 24;
  SKILL_ALLCOMBAT     = 25;
  SKILL_EVERYSKILL    = 26;
  SKILL_NONE          = 27;
}
(*

SkillCoords
~~~~~~~~~~~

.. code-block:: pascal

    function SkillCoords(Row, Column: Integer): TPoint;

Returns Coords of Skill's Row and Column (Used for GetSkill functions)

.. note::

    by NaumanAkhlaQ

Example:

.. code-block:: pascal

*)
function SkillCoords(Row, Column : ShortInt): TPoint;
begin
  Result := Point(576 + (62 * (Column - 1)), 213 + (28 * (Row - 1)));
end;

(*

SkillToCoords
~~~~~~~~~~~~~

.. code-block:: pascal

    function SkillToCoords(Skill: Variant): TPoint;

Turns skill string into TPoint.
If Scroll returns true then you must scroll down.

.. note::

    by Masquerader et. al.

Example:

.. code-block:: pascal

*)
function SkillToCoords(Skill: Variant): TPoint;
var
  SkillArr: TStringArray;
  skNo: Integer;
  SkillS: string;
  SkillPT : TPoint; //Row/Column
begin
  if (not LoggedIn) then exit;

  if VariantIsInteger(Skill) then
    skNo := Skill
  else
  begin;
    SkillS := Lowercase(Skill);
    case Lowercase(SkillS) of
      'hp', 'constitution': SkillS := 'hitpoints';
      'ranged': SkillS := 'range';
      'hunter': SkillS := 'hunting';
      'dung'  : skillS := 'dungeoneering';
    end;

    SkillArr := ['attack', 'defence', 'strength', 'hitpoints', 'range',
                 'prayer', 'magic', 'cooking', 'woodcutting', 'fletching',
                 'fishing', 'firemaking', 'crafting', 'smithing', 'mining',
                 'herblore',  'agility', 'thieving', 'slayer', 'farming',
                 'runecrafting', 'hunting', 'construction', 'summoning',
                 'dungeoneering'];
    if (not InStrArrEx(SkillS, SkillArr, skNo)) then
    begin
      srl_Warn('SkillToCoords',
               'Invalid Skill Name/Number: ''' + string(Skill) + '''',
               warn_AllVersions);
      Exit;
    end;
  end;
  case skNo of
    Skill_Attack        : SkillPT := Point(1,1);
    Skill_Strength      : SkillPT := Point(1,2);
    Skill_Defence       : SkillPT := Point(1,3);
    Skill_Range         : SkillPT := Point(1,4);
    Skill_Prayer        : SkillPT := Point(1,5);
    Skill_Magic         : SkillPT := Point(1,6);
    Skill_RuneCrafting  : SkillPT := Point(1,7);
    Skill_Construction  : SkillPT := Point(1,8);
    Skill_Dungeoneering : SkillPT := Point(1,9);
    Skill_Hitpoints     : SkillPT := Point(2,1);
    Skill_Agility       : SkillPT := Point(2,2);
    Skill_Herblore      : SkillPT := Point(2,3);
    Skill_Thieving      : SkillPT := Point(2,4);
    Skill_Crafting      : SkillPT := Point(2,5);
    Skill_Fletching     : SkillPT := Point(2,6);
    Skill_Slayer        : SkillPT := Point(2,7);
    Skill_Hunter        : SkillPT := Point(2,8);
    Skill_Mining        : SkillPT := Point(3,1);
    Skill_Smithing      : SkillPT := Point(3,2);
    Skill_Fishing       : SkillPT := Point(3,3);
    Skill_Cooking       : SkillPT := Point(3,4);
    Skill_FireMaking    : SkillPT := Point(3,5);
    Skill_WoodCutting   : SkillPT := Point(3,6);
    Skill_Farming       : SkillPT := Point(3,7);
    Skill_Summoning     : SkillPT := Point(3,8);
  else
    begin
      srl_Warn('SkillToCoords', 'Invalid Skill Number: ''' + inttostr(skNo) + '''', warn_AllVersions);
      exit;
    end;
  end;
  Result := SkillCoords(SkillPT.y,SkillPT.x);
end;

(*
GetSkillInfo
~~~~~~~~~~~~

.. code-block:: pascal

    function GetSkillInfo(Skill: Variant; Amount : Boolean): Integer;

Gets the amount / level of a skill.
E.G.
0/15
Amount = True will return 0.
Amount = False will return 15 (The actual level).
Returns -1 if the level couln't be grabbed succesfully

.. note::

    by Raymond

Example:

.. code-block:: pascal
*)
function GetSkillInfo(Skill: Variant; Amount : Boolean): Integer;
var
  TP: TPoint;
  Box : TBox;
  TPA : TPointArray;
  Cts : Integer;

begin
  Result := -1;
  GameTab(tab_Stats);
  TP := SkillToCoords(Skill);
  if (not(Amount)) then
    TP := Point(TP.x + 15,TP.y + 12);
  CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(0);
  if not FindColors(TPA, 36095, TP.x - 2, TP.y - 2, TP.x + 15, TP.y + 15) then
  begin
    ColorToleranceSpeed(CTS);
    exit;
  end;
  Box := GetTPABounds(TPA);
  Result := StrToIntDef(GetNumbers(GetTextAtEx(Box.x1 - 2, Box.y1 -1, 100,
    StatChars, False, True, 0, 3, 36095, 3, True, tr_Digits)), -1);
  ColorToleranceSpeed(CTS);
end;

(*
GetSkillLevel
~~~~~~~~~~~~~

.. code-block:: pascal

    Function GetSkillLevel(skill: Variant): Integer;

Gets the max level for a particular skill.

.. note::

    by Raymond

Example:

.. code-block:: pascal
*)
function GetSkillLevel(Skill: Variant): Integer;
begin
  Result := GetSkillInfo(Skill, False);
end;

(*
IsRunOn
~~~~~~~

.. code-block:: pascal

    function IsRunOn: Boolean;

Returns True if run button is on.

.. note::

    by Slushpuppy

Example:

.. code-block:: pascal
*)
function IsRunOn: Boolean;
begin
  result := CountColorTolerance(3467501, 720, 117, 723, 119, 80) > 1;
end;

(*
IsResting
~~~~~~~~~

.. code-block:: pascal

    function IsResting: Boolean;

Returns True if you are currently resting.

.. note::

    by Sabzi

Example:

.. code-block:: pascal
*)
function IsResting: Boolean;
begin
  result := (CountColorTolerance(3712343,707, 95,732, 122,10)>10);
end;

(*
GetMMLevels
~~~~~~~~~~~

.. code-block:: pascal

    Function GetMMLevels(LevelType : String;var ColorSign : String): integer;

Returns the level shown next to the minimap.
Colorsign returns the color of the text (Green,Yellow,Orange,Red).
Returns -1 if failed.

.. note::

    by Raymond / Wizzup / Sabzi / NCDS

Example:

.. code-block:: pascal

    Value := GetMMLevels( 'hp' ) ;       // Will retrieve your Hit Points
    Value := GetMMLevels( 'pray' ) ;     // Will retrieve your Prayer Points
    Value := GetMMLevels( 'run' ) ;      // Will retrieve your Run energy
    Value := GetMMLevels( 'summon' ) ;   // Will retrieve your Summoning Points

*)
function GetMMLevels(LevelType: string; var ColorSign: string): Integer;
var
  Colors : TIntegerArray;
  Signs: TStringArray;
  P: TPointArray;
  I: Integer;
  B: TBox;
begin;
  Result := -1;
  ColorSign := '';
  case LowerCase(Leveltype) of
    'health', 'hp', 'hitpoints', 'constitution': B := IntToBox(719,27,745,43);
    'prayer', 'pray'                           : B := IntToBox(735,66,762,82);
    'run','energy'                             : B := IntToBox(735,103,762,122);
    'summon', 'summoning'                      : B := IntToBox(719,119,745,156);
  else
    begin;
      srl_Warn('GetMMLevels', 'Invalid LevelType: ''' + LevelType + '', warn_AllVersions);
      Exit;
    end;
  end;
  Colors := [65280, 65535, 2070783, 255];
  Signs  := ['Green', 'Yellow', 'Orange', 'Red'];
  for I := 0 to 3 do
  begin
    With B do
      FindColorsTolerance(P, Colors[i], x1, y1, x2, y2, 30);
    if Length(P) < 1 then
      Continue;
    Result := StrToIntDef(GetNumbers(GetTextAtExWrap(B.X1, B.Y1, B.X2, B.Y2, 0, 4, 4, Colors[i], 20, statChars)), -1);
    if (Result > -1) then
    begin
      ColorSign := Signs[i];
      Exit;
    end;
  end;
end;

(*
GetXP
~~~~~

.. code-block:: pascal

    function GetXP(Skill: Variant): Integer;

Returns current xp for a skill. Returns -1 if failed.

.. note::

    by Nielsie95

Example:

.. code-block:: pascal
*)
function GetXP(skill: variant): integer;
var
  b: TBox;
  p: TPoint;
  tpa: TPointArray;
begin
  result := -1;

  if (not gameTab(TAB_STATS)) then
    exit;

  p := skillToCoords(skill);
  if (p.x < 1) then
    exit;

  mmouse(p.x, p.y + 5, 12, 4);
  wait(400 + random(200));

  if (WaitFindColors(tpa, 15133931, MIX1, MIY1, MIX2, MIY2, 0, 3000)) then
  begin
    b := getTPABounds(tpa);
    wait(400 + random(150));
    result := strToIntDef(getNumbers(getTextAt(b.x1 + 15, b.y1 + 15, 0, 1, 4, 4305653, 0, 75, smallChars)), -1);
  end;
end;

(*
XPTillNextLevel
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function XpTillNextLevel(Skill: Variant): Integer;

Returns current xp until you level up in a skill.
Returns -1 if failed.

.. note::

    by Nielsie95

Example:

.. code-block:: pascal
*)
function XPTillNextLevel(Skill: Variant): Integer;
var
  TPA: TPointArray;
  P: TPoint;
  B: TBox;
begin
  Result := -1;
  if (not TabExists(tab_Stats)) then exit;
  GameTab(tab_Stats);
  if (GetCurrentTab <> tab_Stats) then exit;
  P := SkillToCoords(Skill);
  if (P.x < 1) then exit;
  MMouse(P.x, P.y + 5, 12, 4);
  wait(400 + random(200));
  if (not WaitFindColors(TPA, 15133931, MIX1, MIY1, MIX2, MIY2, 0, 4000)) then exit;
  B := GetTPABounds(TPA);
  Wait(200 + Random(150));
  Result := StrToIntDef(GetNumbers(GetTextAt(B.X1 + 15, B.Y1 + 45, 0, 1, 4, 4305653, 0, 75, SmallChars)), -1);
end;

(*
HPPercent
~~~~~~~~~

.. code-block:: pascal

    function HpPercent: Integer;

Returns Hp left as a percentage.
Does not switch tabs if Players[CurrentPlayer].Level[SKILL_HITPOINTS] (HP level) is set.
Returns -1 if failed.

.. note::

    by Wizzup?

Example:

.. code-block:: pascal
*)
function HPPercent: Integer;
var
  ColorString: string;
begin
  if (Players[CurrentPlayer].Level[SKILL_HITPOINTS] < 1) then
    Players[CurrentPlayer].Level[SKILL_HITPOINTS] := Max(1, GetSkillInfo('hitpoints', False));

  if (Players[CurrentPlayer].Level[SKILL_HITPOINTS] > 1) then
    Result := Round(GetMMLevels('hp', ColorString) * 10 / Players[CurrentPlayer].Level[SKILL_HITPOINTS])
  else
    Result := -1;
end;

(*
GetAllLevels
~~~~~~~~~~~~

.. code-block:: pascal

    procedure GetAllLevels;

Sets all 25 skilllevels to Players.Level[0..24]:
Refer to the 'GameTab 2 Related Functions' above for the order.

.. note::

    by WT-Fakawi & ZephyrsFury

Example:

.. code-block:: pascal
*)
procedure GetAllLevels;
var
  II: Integer;
begin
  try
    for II := 0 to High(Players[CurrentPlayer].Level) do
      Players[CurrentPlayer].Level[II] := GetSkillLevel(II);
  except
    srl_Warn('GetAllLevels', 'CurrentPlayer not declared!', warn_AllVersions);
  end;
end;

(*
Gametab 4
---------

Gametab 4 related functions

*)


(*

Gametab 5
---------

Gametab 5 related functions

*)

(*
EquipmentCoords
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function EquipmentCoords(EquipSlot: Integer): TPoint;

Returns X and Y of the coordinates of the specified equipment item

.. note::

    by RsN modded by WT-Fakawi and Nielsie95

Example:

.. code-block:: pascal

*)

function EquipmentCoords(EquipSlot: Integer): TPoint;
begin
  case EquipSlot of
    1: Result := Point(640, 225);
    2: Result := Point(600, 266);
    3: Result := Point(640, 266);
    4: Result := Point(684, 266);
    5: Result := Point(588, 304);
    6: Result := Point(644, 304);
    7: Result := Point(700, 304);
    8: Result := Point(642, 343);
    9: Result := Point(588, 384);
    10: Result := Point(643, 384);
    11: Result := Point(700, 384);
    else
    begin
      result := Point(-1,-1);
	    srl_warn('EquipmentCoords','Invalid EquipSlot('+inttostr(EquipSlot)+') passed',warn_AllVersions);
    end;
  end;
end;

(*
GetEquippedItemBounds
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function GetEquippedItemBounds(Which: String): TBox;

Returns TBox of eqquipped item in which.

.. note::

    by Nava2

Example:

.. code-block:: pascal

*)
function GetEquippedItemBounds(Which: Variant): TBox;
var
  P: TPoint;
  I: Integer;
begin
  Result := IntToBox(0, 0, 0, 0);
  I := -1;

  if VariantIsString(Which) then
    case Which of
      'helm', 'helmet' :
        I := 1;
      'cape' :
        I := 2;
      'amulet', 'neck', 'necklace' :
        I := 3;
      'arrows', 'bolts' :
        I := 4;
      'right hand', 'weapon' :
        I := 5;
      'plate', 'chest', 'platebody' :
        I := 6;
      'left hand', 'sheild', 'shield' :
        I := 7;
      'legs', 'platelegs', 'skirt', 'plateskirt' :
        I := 8;
      'gloves', 'gauntlets' :
        I := 9;
      'boots':
        I := 10;
      'ring' :
        I := 11;
    end
  else if VariantIsInteger(Which) then
    if (InRange(Which, 1, 11)) then
      I := Which;

  if (I = -1) then
  begin
    SRL_Warn('GetEquiptItemBounds', 'Invalid entry (' + ToStr(Which) + ')', Warn_AllVersions);
    Exit;
  end;

  P := EquipmentCoords(I);
  Result := IntToBox(P.x - 11, P.y - 11, P.x + 11, P.y + 11);
end;

(*
MouseEquippedItem
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure MouseEquippedItem(Which : String; Left : Integer);

Mouses Equipped item like MouseItem.

.. note::

    by Nava2

Example:

.. code-block:: pascal

*)
procedure MouseEquippedItem(Which: String; ClickType: Integer);
var
  B : TBox;
begin
  B := GetEquippedItemBounds(Which);
  if (B.x1 = 0) and (B.x2 = 0) then Exit;
  GameTab(tab_Equip);
  MouseBox(B.x1, B.y1, B.x2, B.y2, ClickType);
end;

(*
WearingItem
~~~~~~~~~~~

.. code-block:: pascal

    function WearingItem(i: Integer): Boolean;

Results True if an item is equipped at equpiment slot defined by I.

.. note::

    by RsN

Example:

.. code-block:: pascal

*)
function WearingItem(I: Integer): Boolean;
var
  X, Y: Integer;
  TP: TPoint;
begin
  Result := false;
  if (not InRange(I, 1, 11)) then
  begin
    srl_Warn('WearingItem', 'Equipment slot #' + IntToStr(I) + ' is not a valid equipment slot', warn_Warning);
    Exit;
  end;
  if (not Gametab(tab_Equip)) then exit;

  TP := EquipmentCoords(I);
  Result := FindColor(X, Y, srl_outline_black, TP.x - 8, TP.y - 8, TP.x + 8, TP.y + 8);
end;

(*
TakeOff
~~~~~~~

.. code-block:: pascal

    procedure TakeOff(I: Integer);

UnEquips Item specified in i.

.. note::

    by RsN

Example:

.. code-block:: pascal

*)
procedure TakeOff(I: Integer);
var
  TP: TPoint;
begin
  TP := EquipmentCoords(I);
  if (WearingItem(I)) then
  begin
    Mouse(TP.x, TP.y, 5, 5, mouse_left);
    Wait(200 + Random(350));
  end;
end;

(*
TakeOffAllExcept
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TakeOffAllExcept(ExceptionSlots: TIntegerArray);

Takes off equipped items defined by StripSlots.

.. note::

    by EvilChicken!

Example:

.. code-block:: pascal

*)
procedure TakeOffAllExcept(ExceptionSlots: TIntegerArray);
var
  I: Integer;
begin
  for I := 1 to 11 do
    if (not InIntArray(ExceptionSlots, I)) then
      TakeOff(I);
end;

(*
TakeOffAllItems
~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TakeOffAllItems;

Takes off all equipped items.

.. note::

    by EvilChicken!

Example:

.. code-block:: pascal

*)
procedure TakeOffAllItems;
begin
  TakeOffAllExcept([]);
end;

(*
CountEquippedItems
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function CountEquippedItems: Integer;

Counts the amount of equipped items. Results "-1" if failed.

.. note::

    by EvilChicken!

Example:

.. code-block:: pascal

*)
function CountEquippedItems: Integer;
var
  I: Integer;
begin
  Result := Ord(GameTab(tab_Equip)) - 2;
  if (Result = -1) then exit;

  for I := 1 to 11 do
    if WearingItem(I) then
      Inc(Result);
end;

(*
Gametab 6
---------

Gametab 6 related functions

*)

(*
Gametab 7
---------

Gametab 7 related functions

*)

(*
Gametab 8
---------

Gametab 8 related functions

*)

(*
CurrentWorld
~~~~~~~~~~~~

.. code-block:: pascal

    function CurrentWorld: Integer;

Returns current world from Friends Tab

.. note::

    by Home

Example:

.. code-block:: pascal

*)
function CurrentWorld: Integer;
var
  Box :TBox;
  TPA :TPointArray;
begin
  Result := - 1;
  if (GetCurrentTab <> tab_Friends) then
  begin
    GameTab(tab_Friends);
    Wait(250 + Random(500));
  end;
  FindColors(TPA, 3381759, 601, 223, 703, 238);
  Box := GetTPABounds(TPA);
  Result := StrToIntDef(ExtractFromStr(GetTextAtExWrap(Box.X1, Box.Y1, Box.X2, Box.Y2, 0, 3, 4, 3381759, 0, UpChars), Numbers), - 1);
  if (Result = - 1) then
    srl_Warn('CurrentWorld', 'Could not get Player''s current world', Warn_AllVersions);
end;

(*

Gametab 9
---------

Gametab 9 related functions

*)

(*
ObjectivePercent
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ObjectivePercent: Integer;

Returns (Roughly) Objective Completion in Percent.
Results -1 if failed.

.. note::

    by r!ch!e

Example:

.. code-block:: pascal

*)
function ObjectivePercent: Integer;
begin
  Result := -1;
  if (not GameTab(tab_Objectives)) then exit;
  Result := Round(CountColor(42516, 596, 390, 690, 400) / 9.73);
end;

(*
ObjectiveCoords
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function ObjectiveCoords(ObjSlot: Integer): TPoint;

Returns Coords of Random Objective Slot (ObjSlot : 1..6)

.. note::

    by r!ch!e & Naum

Example:

.. code-block:: pascal

*)
function ObjectiveCoords(ObjectiveSlot: Byte): TPoint;
begin
  if (not InRange(ObjectiveSlot, 1, 6)) then
  begin
    srl_Warn('ObjectiveCoords', 'Invalid Slot', Warn_AllVersions);
    Exit;
  end;
  Result.y := Trunc(ObjectiveSlot / 2) + 1;
  if (Result.y mod 2 = 0) then
    Dec(Result.y);
  Result.x := ObjectiveSlot mod 3;
  if (Result.x = 0) then
    Result.x := 3;
  Result := Point(RandomRange(20 + 165 * (Result.x - 1), 160 + 165 * (Result.x - 1)),
    RandomRange(50 + 65 * (Result.y - 1), 160 + 65 * (Result.y - 1)));
end;

(*
HasObjective
~~~~~~~~~~~~

.. code-block:: pascal

    function HasObjective: Boolean;

Returns True if an Objective is set.

.. note::

    by r!ch!e

Example:

.. code-block:: pascal

*)
function HasObjective: Boolean;
begin
  Result := False;
  if (GameTab(tab_Objectives)) then
    Result := (GetColor(582, 267) <> 3029570)
  else
    srl_Warn('HasObjective', 'Failed to open GameTab #' +
      IntToStr(tab_Objectives), Warn_AllVersions);
end;

(*
ClearObjective
~~~~~~~~~~~~~~

.. code-block:: pascal

    function ClearObjective: Boolean;

Returns True if an Objective is Cleared, or no Objective Exists.

.. note::

    by r!ch!e

Example:

.. code-block:: pascal

*)
function ClearObjective: Boolean;
begin
  Result := HasObjective;
  if (Result) then
    MouseBox(559, 447, 724, 456, mouse_left)
  else
    srl_Warn('ClearObjective', 'No Objective to Clear', Warn_AllVersions);
end;

(*
SetObjective
~~~~~~~~~~~~

.. code-block:: pascal

    function SetObjective(Skill: String; Level: Integer): Boolean;

Sets Objective according to Skill and Level.
Returns True if Objective is set.

.. note::

    by r!ch!e

Example:

.. code-block:: pascal

*)
function SetObjective(Skill: string; Level: Integer): Boolean;
var
  TP: TPoint;
begin
  Result := False;
  if (not InRange(Level, 1, 99)) then
  begin
    srl_Warn('SetObjective', IntToStr(Level) + ' is not a valid level', Warn_AllVersions);
    Exit;
  end;

  if (not GameTab(tab_Stats)) then exit;
  TP := SkillToCoords(Skill);
  Mouse(TP.x, TP.y + 3, 2, 2, mouse_right);
  WaitOption('bjec', 300 + Random(500));
  Wait(1000 + Random(250));
  if (FindTextTpa(clBlack, 0, 100, 390, 235, 410, 'Enter the skill', UpCharsEx, Nothing)) then
  begin
    Wait(1000 + Random(250));
    TypeSend(IntToStr(Level));
    Result := True;
  end;
end;

(*
SetRandomObjective
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function SetRandomObjective(ObjectiveSlot: Integer; KeepOld: Boolean): Boolean;

Sets a Random Objective Slot (ObjSlot : 1..6). If an objective is
already set KeepOld determines if it is overwritten.
Returns True if Objective is set.

.. note::

    by r!ch!e

Example:

.. code-block:: pascal

*)
function SetRandomObjective(ObjectiveSlot: Integer; KeepOld: Boolean): Boolean;
var
  ObjP: TPoint;
begin
  Result := False;
  if not InRange(ObjectiveSlot, 1, 6) then
  begin
    srl_Warn('SetRandomObjective', 'Invalid Objective Slot', Warn_AllVersions);
    Exit;
  end;

  if (not GameTab(tab_Objectives)) then exit;
  if (HasObjective) and (KeepOld) then exit;

  MouseBox(556, 422, 725, 432, mouse_left);
  Wait(400 + Random(350));
  ObjP := ObjectiveCoords(ObjectiveSlot);
  Mouse(ObjP.x, ObjP.y, 0, 0, mouse_left);
  Result := HasObjective;
end;

(*

Gametab 10
----------

Gametab 10 related functions

*)

(*

Gametab 11
----------

Gametab 11 related functions

*)

(*
SetRun
~~~~~~

.. code-block:: pascal

    function SetRun(Run: Boolean): Boolean;

Sets Run on or off.

.. note::

    by Wizzup? & EvilChicken!

Example:

.. code-block:: pascal

*)

function SetRun(Run: Boolean): Boolean;
begin
  Result := false;                                                                  //Color near center of Run icon
  if (((CountColorTolerance(3467501, 720, 117, 723, 119, 80) > 1) or (SimilarColors(GetColor(725, 111), 6740459, 10)))  xor (Run)) then
  begin
    Mouse(715, 95, 10, 10, mouse_left);
    Result := True;
  end;
end;

(*
RunEnergy
~~~~~~~~~

.. code-block:: pascal

    function RunEnergy(Min: Integer): Boolean;

Toggles run if energy is greater or equal to MinEnergy. Results
true if energy is greater or equal to minimum.

.. note::

    by lordsaturn & NCDS

Example:

.. code-block:: pascal

*)
function RunEnergy(Min: Integer): Boolean;
var
  T, R: Integer;
  s: String;
begin
  T := GetSystemTime + 5000;
  repeat
    R := GetMMLevels('run', s);
    Result := (R >= Min);
    if (Result) then
    begin
      SetRun(True);
      Exit;
    end;
    if (R > 0) then
      Exit;
  until (T > GetSystemTime);
end;

(*
SetRest
~~~~~~~

.. code-block:: pascal

    function SetRest: Boolean;

Turns Rest on. Result True if successful.

.. note::

    by ZephyrsFury, edited by NCDS

Example:

.. code-block:: pascal

*)
function SetRest: Boolean;
begin
  Result := False;
  if (not(IsResting)) then
  begin
    Mouse(715, 95, 10, 10, mouse_right);
    if (WaitOption('Rest', 300)) then
      Result := WaitFunc(@IsResting, 100, 5000);
  end;
end;

(*
RestUntil
~~~~~~~~~

.. code-block:: pascal

    function RestUntil(Energy: Integer): Boolean;

Rests until your Run energy is above Energy. Results True if successful.

.. note::

    by ZephyrsFury

Example:

.. code-block:: pascal

*)
function RestUntil(Energy: Integer): Boolean;
var
  S: string;
begin
  Result := (GetMMLevels('run', S) >= Energy);
  if (Result) then exit;
  SetRest;
  while (GetMMLevels('run', S) < Energy) do
  begin
    Result := IsResting;
    if (not(Result)) then exit;
    if SRL_HasProc(srl_AntiBan) then
      SRL_Procs[srl_AntiBan]();
    Wait(100 + Random(50));
  end;
end;

(*
RestUntilHP
~~~~~~~~~~~

.. code-block:: pascal

    function RestUntilHP(HPPerc: Integer): Boolean;

Rests until your Run energy is above the given HP percentage. Results True if 
successful.

.. note::

    by Mama

Example:

.. code-block:: pascal

*)
function RestUntilHP(HPPerc: Integer): Boolean;
begin
  Result := (HPPercent >= HPPerc);
  if (Result) then exit;
  SetRest;
  while (HPPercent < HPPerc) do
  begin
    Result := IsResting;
    if (not(Result)) then exit;
    if SRL_HasProc(srl_AntiBan) then
      SRL_Procs[srl_AntiBan]();
    Wait(100 + Random(50));
  end;
end;

Const
  BrightnessColor = 9605778;
  ScrollColor = 2106924;
  ArrowOptions = 16645886;
  BlueText = 14790912;

(*
FixGraphics
~~~~~~~~~~~

.. code-block:: pascal

    procedure FixGraphics;

Fixes the Graphic Options if LoggedIn

.. note::

    by Naum & Rasta Magician

Example:

.. code-block:: pascal

*)
procedure FixGraphics;
var
  I, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  TP : TPoint;
  TB : TBox;
begin
  if (not LoggedIn) then exit;
  CloseWindow;

  if (not FindColor(x, y, ClBlack, 7, 460, 69, 474)) then   {if you're in chat}
    if (not ClickContinue(True, True)) then
    begin
      Mouse(MMCX, MMCY, 2, 2, mouse_left);
      Wait(RandomRange(3000, 4000));
    end;

  i := 0;                       //failsafe opening clause
  while (not FindTextTPA(ClWhite, 0, MSX1, MSY1, MSX2, MSY2, 'aphics', UpCharsEx, Nothing)) and (LoggedIn) do
  begin
    GameTab(tab_Options);
    MouseBox(605, 258, 623, 277, mouse_left);
    Wait(1000 + Random(500));
    Inc(i);
    if (i > 3) then
    begin
      srl_Warn('SetGraphics', 'Could not open Graphics Options screen', warn_Warning);
      CloseWindow;
      Exit;
    end;
  end;

  If FindTextTPA(ClWhite, 0, MSX1, MSY1, MSX2, MSY2, 'aphics', UpCharsEx, Nothing) Then
    Mouse(386, 172, 30, 10, mouse_left);

  if GetColor(255, 178) = BrightnessColor then
    Mouse(255, 178, 2, 2, mouse_left);               //Sets brightness
  Wait(1000 + Random(400));                 //waits for it

  FindColors(TPA, ArrowOptions, MSX1, MSY1, MSX2, MSY2);  //finds drop down arrows
  ATPA := SplitTPA(TPA, 5);         //gets individual arrows
  SortATPAFromFirstPoint(ATPA, Point(197, 89));     //sorts them

  for I := 0 to High(ATPA) do
  begin
    TP := MiddleTPA(ATPA[I]);
    TB := IntToBox(TP.X - 60, TP.Y - 5, TP.X + 2, TP.Y + 5);

    if (CountColor(BlueText, TB.X1, TB.Y1, TB.X2, TB.Y2) > 5) then //if its not optimum
    begin
      Mouse(TP.X, TP.Y, 3, 3, mouse_left);

      GetMousePos(X, Y);
      If IntInBox(X, Y, IntToBox(236, 308, 462, 587)) Then
      if (CountColor(ClWhite, 201, 295, 226, 308) > 5) then  //clicks the correct one
      begin
        MouseBox(201, 295, 226, 308, mouse_left);
        Wait(900 + Random(100));
      end;

      If Not IntInBox(X, Y, IntToBox(236, 308, 462, 587)) Then
      if (CountColor(ClWhite, TB.X1, TB.Y1 + 20, TB.X2, TB.Y2 + 15) > 5) then  //clicks the correct one
      begin
        MouseBox(TB.X1, TB.Y1 + 20, TB.X2 - 15, TB.Y2 + 15, mouse_left);
        Wait(900 + Random(100));
      end;

    end;
  end;
  CloseWindow;
  CloseWindow;
end;

(*
SetGraphics
~~~~~~~~~~~

.. code-block:: pascal

    procedure SetGraphics(Brightness: Integer; vl, rr, gd, td, id, fe, gt, cs: string);

Sets graphic options through the Graphics Screen in GameTab 11.
Use: Enter the desired Setting for the desired Option. Leave as '' for no change


Parameter    Option                Setting
vl           Visible Levels        Current / All
rr           Remove Roofs          Always / Selectively
gd           Ground Decoration     Off / On
td           Texture Detail        Low / High
ia           Idle Animations       Few / Many
fe           Flickering Effects    Off / On
gt           Ground Textures       Few / Many
cs           Character Shadows     Off / On

|                          1   2   3   4   
|        Brightness:   <---o---o---o---o--->

EG. SetGraphics(2, 'current', '', 'off', 'low', 'few', '', 'few', 'off');
For Autoing: SetGraphics(4, 'current', 'always', 'off', 'low', 'few', 'off', 'few', 'off');
OutDated since 02 Sep 09

.. note::

    by ZephyrsFury

Example:

.. code-block:: pascal

*)
procedure SetGraphics(Brightness: Integer; vl, rr, gd, td, ia, fe, gt, cs: string);
var
  Settings, PosSettings, OptionName, tArr: TStringArray;
  TB: TBox;
  II, Tx, Ty, Col, Where: Integer;
  P: TPoint;
begin
  if (not LoggedIn) then exit;
  CloseWindow;

  if (not FindColor(Tx, Ty, 0, 7, 460, 69, 474)) then
    if (not ClickContinue(True, True)) then
      Mouse(MMCX, MMCY, 2, 2, mouse_left);

  II := 0;
  while (not FindTextTPA(2070753, 0, MSX1, MSY1, MSX2, MSY2, 'Graphics Options', UpCharsEx, Nothing)) and (LoggedIn) do
  begin
    GameTab(tab_Options);
    MouseBox(605, 258, 623, 277, mouse_left);
    Wait(500 + Random(200));
    Inc(II);
    if (II > 3) then
    begin
      srl_Warn('SetGraphics', 'Could not open Graphics Options screen', warn_Warning);
      CloseWindow;
      Exit;
    end;
  end;

  if (not InRange(Brightness, 0, 4)) then
    srl_Warn('Login_SetGraphics', 'Brightness must be between 0 and 4', warn_AllVersions)
  else
    if (Brightness <> 0) then
    begin
      P := Point(140 + ((Brightness - 1) * 31), 185);
      if (GetColor(P.x, P.y) = srl_outline_black) then
        Mouse(P.x - 2, P.y - 2, 5, 5, mouse_left);
    end;

  PosSettings := ['Current', 'All', 'Always', 'Selectively', 'Off', 'On', 'Low',
    'High', 'Few', 'Many', 'Off', 'On', 'Few', 'Many', 'Off', 'On'];
  OptionName := ['Visible Levels', 'Remove Roofs', 'Ground Decoration', 'Texture Detail',
    'Idle Animations', 'Flickering Effects', 'Ground Textures', 'Character Shadows'];
  Settings := [vl, rr, gd, td, ia, fe, gt, cs];

  for II := 0 to High(Settings) do
  begin
    if (Settings[II] = '') then Continue;

    TB.x1 := 149 + ((II + 1) div 7) * 239;
    TB.y1 := 173 + ((II + 1) mod 7) * 17;
    TB.x2 := TB.x1 + 104;
    TB.y2 := TB.y1 + 14;

    tArr := [PosSettings[II * 2], PosSettings[II * 2 + 1]];
    if (not(InStrArrEx(Capitalize(Settings[II]), tArr, Where))) then
    begin
      srl_Warn('SetGraphics', 'Setting: ' + Settings[II] + ' is not valid for Option: ' + OptionName[II], warn_AllVersions);
      Continue;
    end;

    Col := Where * 16777008 + 207;
    if (FindColor(Tx, Ty, Col, TB.x1, TB.y1, TB.x2, TB.y2)) then Continue;

    Mouse(TB.x1 + 10, TB.y1 + 3, 10, 5, mouse_left);
    Wait(50 + Random(100));

    if (FindColor(Tx, Ty, Col , TB.x1, TB.y2 + 1, TB.x2, TB.y2 + 1 + 51)) then
    begin
      Mouse(Tx, Ty, 10, 5, mouse_left);
      Wait(50 + Random(100));
      while (CountColor(16777215, 5, 5, 161, 35) > 100) do Wait(100 + Random(50));
    end else
      Mouse(TB.x1 + 10, TB.y1 + 3, 10, 5, mouse_left);
  end;

  Wait(500 + Random(500));
  CloseWindow;
end;

(*
SetAudio
~~~~~~~~

.. code-block:: pascal

    procedure SetAudio(Volume, SFX, Area: Integer; SMSetting: (Stereo, Mono, NoChange) );

Sets audio options through the Audio screen in GameTab 11
Use: Enter the desired Setting AS A POINT for the desired Option. Make option 0
for no change.

|                           1   2   3   4   5
|    Volume, SFX, Area:  <--o---o---o---o---o-->

EG. SetAudio(1, 4, 0, Stereo);

.. note::

    by ZephyrsFury

Example:

.. code-block:: pascal

*)
procedure SetAudio(Volume, SFX, Area: Integer; SMSetting: TSMSetting);
var
  Settings: TIntegerArray;
  OptionName: TStringArray;
  II, C, Tx, Ty: Integer;
  P: TPoint;
begin
  if (not LoggedIn) then exit;

  Settings := [Volume, SFX, Area];
  OptionName := ['Volume', 'SFX', 'Area'];

  C := 0;
  CloseWindow;
  if (not FindColor(Tx, Ty, 0, 7, 460, 69, 474)) then
    if (not ClickContinue(True, True)) then
      Mouse(MMCX, MMCY, 2, 2, mouse_left);

  while (not FindTextTPA(2070753, 0, MSX1, MSY1, MSX2, MSY2, 'Audio Options', UpCharsEx, Nothing)) and (LoggedIn) do
  begin
    GameTab(tab_Options);
    MouseBox(654, 252, 677, 278, mouse_left);
    Wait(500 + Random(200));
    Inc(C);
    if (C > 3) then
    begin
      srl_Warn('SetAudio', 'Could not open Audio Options screen', warn_Warning);
      CloseWindow;
      Exit;
    end;
  end;

  for II := 0 to 2 do
  begin

    if (not InRange(Settings[II], 0, 5)) then
    begin
      srl_Warn('SetAudio', IntToStr(Settings[II]) + ' is not a valid setting ' +
        'for: ' + OptionName[II] + '. Must be between 0 and 5', warn_AllVersions);
      Continue;
    end;

    if (Settings[II] = 0) then Continue;

    P.x := Round(201.0 + 25.5 * (Settings[II] - 1));
    P.y := Round(1.5 * II * II + 54.5 * II + 118.0);
    if (GetColor(P.x, P.y) <> 16777215) then
      Mouse(P.x - 6, P.y, 0, 5, mouse_left);

    Wait(10 + Random(10));
  end;

  if (GetColor(238, 268) = 181) and (SMSetting = Stereo) then
    Mouse(302, 265, 7, 7, mouse_left)
  else
    if (GetColor(305, 268) = 181) and (SMSetting = Mono) then
      Mouse(235, 265, 7, 7, mouse_left);

  Wait(500 + Random(500));
  CloseWindow;
end;

(*
SetBar
~~~~~~

.. code-block:: pascal

    procedure SetBar(Brightness, Volume, SFX, Area: Integer);

Sets each bar to the specific point. 1-4 for Brightness, 1-5 for
others. For no change in the value make the respective parameter 0.

.. note::

    by ZephyrsFury

Example:

.. code-block:: pascal

*)
procedure SetBar(Brightness, Volume, SFX, Area: Integer);
var
  Settings: TIntegerArray;
  Names: TStringArray;
  II, K: Integer;
begin
  Settings := [Brightness, Volume, SFX, Area];
  Names := ['Brightness', 'Volume', 'SFX', 'Area'];
  for II := 0 to 3 do
  begin
    K := 5 - Integer(II = 0);
    if (not InRange(Settings[II], 0, K)) then
    begin
      srl_Warn('SetBar', 'Setting: ' + IntToStr(Settings[II]) + ' is not valid for Bar: ' + Names[II] + '.', warn_AllVersions);
      Settings[II] := 0;
    end;
  end;
  SetGraphics(Settings[0], '', '', '', '', '', '', '', '');
  Wait(100 + Random(500));
  SetAudio(Settings[1], Settings[2], Settings[3], NoChange);
end;

(*

Gametab 12
----------

Gametab 12 related functions

*)

(*
DoEmote
~~~~~~~

.. code-block:: pascal

    procedure DoEmote(EmoteNumber: Integer);

Clicks on an emote specified by EmoteNumber (1 to 37)

.. note::

    by NaumanAkhlaQ

Example:

.. code-block:: pascal

*)
procedure DoEmote(EmoteNumber: Integer);
var
  I, X, Y, Row, Col: Integer;

begin
  if (not InRange(EmoteNumber, 1, 51)) then
  begin
    srl_Warn('DoEmote', 'Invalid EmoteNumber: ' + IntToStr(EmoteNumber) + ', Valid Emotes: 1..46', warn_AllVersions);
    Exit;
  end;

  if (GetCurrentTab <> tab_Emotes) then
  begin
    if (not GameTab(tab_Emotes)) then exit;
    Wait(500 + Random(750));
  end;

  case EmoteNumber of
    01..20: if (GetColor(723, 226) = 2041131) then
              Mouse(723, 226, 8, 4, mouse_left);
    21..40: if (GetColor(727, 364) = 1909544) then
              Mouse(727, 354, 4, 1, mouse_left);
    41..51: if (GetColor(725, 438) = 1909544) then
              Mouse(725, 438, 5, 5, mouse_left);
  end;
  Wait(300 + Random(200));
  if InRange(EmoteNumber, 21, 40) then
    I := 20
  else
    if InRange(EmoteNumber, 41, 51) then I := 28;
  DecEx(EmoteNumber, I);

  Row := Trunc(EmoteNumber / 4) + 1;
  if ((EmoteNumber mod 4) = 0) then Dec(Row);
  Col := (EmoteNumber mod 4);
  if (Col = 0) then Col := 4;

  X := 550 + (44 * (Col - 1));
  Y := 219 + (49 * (Row - 1));
  Mouse(X, Y, 26, 39, mouse_left);
end;

(*
GetLobbyTab
~~~~~~~~~~~

.. code-block:: pascal

    function GetLobbyTab: Integer;

Gets current lobby tab.

.. note::

    by Bionicle1800, NCDS

Example:

.. code-block:: pascal

*)
function GetLobbyTab: Integer;
begin
  for result := 1 to 6 do
    if GetColor(63 + (result-1)*102, 32) = 11582147 then //Midpoint of the left boundary of the tab
      Exit;
  Result := -1;
end;

(*
LobbyTab
~~~~~~~~

.. code-block:: pascal

    function LobbyTab(Tab: Integer): Boolean;

Goes to the lobby tab specified by the integer 'Tab'.
Valid arguments are 1 through 5, as well as PlayerInfo,
WorldSelect, FriendsList, ClanChat and Options.

.. note::

    by Bionicle1800

Example:

.. code-block:: pascal

*)
function LobbyTab(Tab: Integer): Boolean;
begin
  Result := false;
  if not InRange(Tab, L_PlayerInfo, L_Options) then
  begin
    Srl_Warn('LobbyTab', 'Tab ' + IntToStr(Tab) + ' is not valid.', warn_AllVersions);
    Exit;
  end;
  result := GetLobbyTab = Tab;
  if result then
   Exit;
  if GetColor(63 + (Tab-1)*102, 32) = 8095117 then //Midpoint of the left boundary of the tab; this is the resultant color when the tab is active
  begin
    Mouse(63 + (Tab-1)*102, 32, 10, 6, mouse_left);
    result := true;
  end;
end;

(*

XP Counter
----------

XP Counter related functions

*)

 (*
ToggleXPPopUp
~~~~~~~~~~~~~

.. code-block:: pascal

    Function ToggleXPPopUp(Disabled: Boolean): Boolean;

Toggles the XP Pop-up to on/off that shows up on main screen.
This uses the chat messages to determine if its off or on.
  ToggleXPPopUp(True) turns it off and returns True if successful
  ToggleXPPopUp(False) turns it on and returns True if successful

.. note::

    by Narcle

*)
Function ToggleXPPopUp(Disabled: Boolean): Boolean;
var
  i: Integer;
  TPA: TPointArray;
  P: TPoint;
  S: String;
begin
  for i := 0 to 1 do
  begin
    TPA := TPAFromBox(IntToBox(521, 51, 546, 75));
    FilterPointsPie(TPA, 0, 360, 0, 12, 534, 63);
    P := TPA[Random(Length(TPA))];
    Mouse(P.X, P.Y, 0, 0, mouse_right);
    if WaitOptionMulti(['Pop', 'op', '-up'], 1000) then
    begin
      Wait(1500+Random(500));
      S := GetBlackChatMessage;
      if Pos('disabled', S) > 0 then
        Result := Disabled;
      if Pos('enabled', S) > 0 then
        Result := not Disabled;
      if Result then
        Break;
    end;
  end;
  Writeln(S);
end;

(*
ISXPBarOpenEx
~~~~~~~~~~~~~

.. code-block:: pascal

    function IsXPBarOpen(CounterNum: integer): Boolean;

Results True if the XP Bar is showing. Counter number 1 to 3

.. note::

    by Narcle & IceFire908

*)


function IsXPBarOpenEx(CounterNum: integer): Boolean;
begin
  Result := CountColor(14474460, 481, 10+(CounterNum-1)*22, 489, 22+(CounterNum-1)*22) > 6;
end;


(*
ISXPBarOpen
~~~~~~~~~~~

.. code-block:: pascal

    function IsXPBarOpen: Boolean;

Results True if the XP Bar is showing.
Added for compatability

.. note::

    by Narcle & IceFire908

*)
function IsXPBarOpen: Boolean;
begin
  Result := IsXPBarOpenEx(1);
end;

(*
ToggleXPBarEx
~~~~~~~~~~~~~

.. code-block:: pascal

    function ToggleXPBarEx(Open: Boolean; CounterNum: integer): Boolean;

Opens or closes the XP Bar, true if had to toggle.
Counter number 1 to 3

.. note::
    by Narcle & IceFire908

*)

function ToggleXPBarEx(Open: Boolean; CounterNum: integer): Boolean;
var
  TPA: TPointArray;
  P: TPoint;
  T: Integer;
begin
  if Open xor IsXPBarOpenEx(CounterNum) then
  begin
    TPA := TPAFromBox(IntToBox(521, 51, 546, 75));
    FilterPointsPie(TPA, 0, 360, 0, 12, 534, 63);
    P := TPA[Random(Length(TPA))];
    Mouse(P.X, P.Y, 0, 0, mouse_left);
    T := GetSystemTime + 300;
    repeat
      wait(1);
      Result := Open = IsXPBarOpenEx(CounterNum);
    until Result or (GetSystemTime > t);
  end else
    Result := true;
end;

(*
ToggleXPBar
~~~~~~~~~~~

.. code-block:: pascal

    function ToggleXPBar(Open: Boolean): Boolean;

Opens or closes the XP Bar, true if had to toggle.

.. note::
    by Narcle & IceFire908

*)
function ToggleXPBar(Open: Boolean): Boolean;
begin
  Result := ToggleXPBarEx(Open, 1);
end;

(*
GetXPBar
~~~~~~~~

.. code-block:: pascal

    function GetXPBar(CounterNum: integer): LongInt;

Returns the number from your XP Bar.
Counter number 1 to 3

.. note::

    by Narcle & IceFire908 edited by Ashaman88
*)
Function GetXPBar(CounterNum: integer): LongInt;
var
  TPA: TPointArray;
  B: TBox;
  S: String;
  P: integer;
begin
  Result:=-1;
  if ToggleXPBarEx(true, CounterNum) then
  begin
    FindColorsTolerance(TPA, 14474460, 407, 10+(CounterNum-1)*22, 489, 24+(CounterNum-1)*22, 0);
    B := GetTPABounds(TPA);
    S := Replace(GetTextAtExWrap(B.x1, B.y1, B.x2, B.y2, 0, 1, 4, 14474460, 0, UpChars), ' ', '');
    P := Pos('x', S);
    if P > 0 then
      Result := StrToIntDef(ExtractFromStr(Copy(s, P, Length(S)), Numbers), 0)
    else
      Result := StrToIntDef(ExtractFromStr(S, Numbers), 0);
  end;
end;

(*
GetXPBarTotal
~~~~~~~~~~~~~

.. code-block:: pascal

    function GetXPBarTotal: LongInt;

Returns the number from your XP Bar.

.. note::

    by Narcle & IceFire908
*)

function GetXPBarTotal: LongInt;
begin
  Result := GetXPBar(1);
end;

(*
ResetXPTotal
~~~~~~~~~~~~

.. code-block:: pascal

    function ResetXPTotal: Boolean;

Resets the XP Bar.

.. note ::

    by Narcle & IceFire908

*)
function ResetXPTotal: Boolean;
var
  TPA: TPointArray;
  P: TPoint;
begin
  TPA := TPAFromBox(IntToBox(521, 51, 546, 75));
  FilterPointsPie(TPA, 0, 360, 0, 12, 534, 63);
  P := TPA[Random(Length(TPA))];
  Mouse(P.X, P.Y, 0, 0, mouse_right);
  Result := WaitOptionMulti(['Res', 'ese', 'set'], 1000);
end;


(*

MoneyPouch Tab
--------------

Money Pouch related functions

*)

(*
IsMoneyPouchOpen
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function IsMoneyPouchOpen: Boolean;

Checks if money pouch is open.

.. note ::

    by Home

*)
function IsMoneyPouchOpen: Boolean;
var
 Cols :TIntegerArray;
 I :Integer;
begin
  Cols := [65535, 16777215, 8453888];
  for I := 0 to 2 do
    If CountColor(Cols[I],450, 90, 510, 109) > 10 then
      Result := CountColor(Cols[I],450, 90, 510, 109) > 10;
end;

(*
ToggleMoneyPouch
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    ToggleMoneyPouch(Open: Boolean): Boolean;

Opens the money pouch if closed.

.. note ::

    by Home

*)
function ToggleMoneyPouch(Open: Boolean): Boolean;
begin
  Result := IsMoneyPouchOpen <> Open;
  if (not (Result)) then
    Exit;
  MouseBox(528, 94, 533, 107, mouse_Left);
end;

(*
GetMoneyPouchAmount
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function GetMoneyPouchAmount: LongInt;

Returns amount of coins in pouch.

.. note ::

    by Home & Richard

Example:

.. code-block:: pascal

    amt := GetMoneyPouchAmount();

*)
function GetMoneyPouchAmount: Integer;
var
  Previous: Boolean;
  TPA: TPointArray;
  B: TBox;
  I :Integer;
  Col :TIntegerArray;
  Money :String;
begin
  Previous := IsMoneyPouchOpen;
  if (ToggleMoneyPouch(True)) then
  WaitFunc(@IsMoneyPouchOpen, 10, 2750);
  Col := [65535, 65278, 16777215, 8453888];
  for I := 0 to 3 do
  if (FindColors(TPA, Col[I], 450, 90, 510, 109)) then
  begin
    B := GetTPABounds(TPA);
    B := IntToBox(B.X1 - 2, B.Y1 - 2, B.X2 + 2, B.Y2 + 2);
    Money := (GetTextAtEx(B.X1 - 1, B.Y1 - 1, 0, StatChars, False, False, 0, 2, Col[I], 5, False, tr_AllChars));
    Result := StrToIntDef(GetNumbers(Money), -1);
    If Pos('K', Money) > 0 then
      Result := Result * 1000;
    If Pos('M', Money) > 0 then
      Result := Result * 1000000;
    break;
  end;
  if (not(Previous)) then
  begin
    Wait(RandomRange(500, 1500));
    ToggleMoneyPouch(Previous);
  end;
end;

(*
DepositToPouch
~~~~~~~~~~~~~~

.. code-block:: pascal

    function DepositToPouch :Boolean;

Deposit's coins to pouch.

.. note ::

    by Home

*)
function DepositToPouch :Boolean;
var
 MoneyPoint :TPoint;
begin
  Result := False;
  If FindCoins(MoneyPoint.X, MoneyPoint.Y, 'Inv') then
    begin
      MMouse(MoneyPoint.X, MoneyPoint.Y, 3, 3);
      If WaitUpText('Coins', 500) then
      begin
        Mouse(MoneyPoint.X, MoneyPoint.Y, 0, 0, False);
          Result := WaitOption('Add', 500);
      end;
    end;
end;

(*
toolBeltScreen
~~~~~~~~~~~~~~

.. code-block:: pascal

    function toolBeltScreen : Boolean;

Returns True if the Tool Belt screen is open

.. note::

    by Kyle Undefined

Example:

.. code-block:: pascal

*)
function ToolBeltScreen() : Boolean;
begin
  Result := (CountColorTolerance(1158880, 192, 18, 264, 33, 9) > 120);
end;

(*
itemSlotFilled
~~~~~~~~~~~~~~

.. code-block:: pascal

    function itemSlotFilled : Boolean;

Returns True if the current tool slot is filled

.. note::

    by Kyle Undefined

Example:

.. code-block:: pascal

*)
function ItemSlotFilled() : Boolean;
var
  TPA : TPointArray;
  tmpCTS : Integer;
begin
  tmpCTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(1.86, 0.06);

  FindColorsSpiralTolerance(MSCX, MSCY, TPA, 5855064, 211, 199, 298, 273, 9);

  ColorToleranceSpeed(tmpCTS);
  SetColorSpeed2Modifiers(0.2, 0.2);

  Result := Length(TPA) > 0;
end;

(*
openToolBelt
~~~~~~~~~~~~

.. code-block:: pascal

    procedure toolBeltScreen;

Opens the Tool Belt

.. note::

    by Kyle Undefined, edited by riwu.

Example:

.. code-block:: pascal

*)
procedure OpenToolBelt();
begin
  GameTab(tab_Equip);
  MouseBox(644, 416, 682, 450, mouse_Left);
  Wait(RandomRange(250, 750));
end;

(*
setCategory
~~~~~~~~~~~

.. code-block:: pascal

    procedure setCategory(Category : string);

Sets the category of items to be shown

.. note::

    by Kyle Undefined

Example:

.. code-block:: pascal

*)
procedure SetCategory(Category : string);
var
  catBox : TBox;
  TPA : TPointArray;
  tmpCTS : Integer;
begin
  case(LowerCase(Category))of
    'general' : catBox := IntToBox(161, 86, 188, 107);
    'fishing' : catBox := IntToBox(219, 86, 246, 104);
    'crafting' : catBox := IntToBox(275, 87, 305, 104);
    'farming' : catBox := IntToBox(332, 88, 359, 105);
  end;

  tmpCTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.34, 0.80);

  FindColorsSpiralTolerance(MSCX, MSCY, TPA, 1810641, catBox.X1, catBox.Y1, catBox.X2, catBox.Y2, 9);

  ColorToleranceSpeed(tmpCTS);
  SetColorSpeed2Modifiers(0.2, 0.2);

  if(not(Length(TPA) > 0))then
    MouseBox(catBox.X1, catBox.Y1, catBox.X2, catBox.Y2, 1);
end;

(*
checkToolBeltFor
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function checkToolBeltFor(Category, Tool : string) : Boolean;

Returns True if the tool is in Tool Belt for the appropriate category

.. note::

    by Kyle Undefined

Example:

.. code-block:: pascal

*)
function CheckToolBeltFor(Category, Tool : string) : Boolean;
var
  I, catCount : Integer;
begin
  if(not(toolBeltScreen()))then
    openToolBelt();
  setCategory(Category);

  case(LowerCase(Category))of
    'general', 'crafting' : catCount := 13;
    'fishing' : catCount := 8;
    'farming' : catCount := 5;
  end;

  for I := 1 to catCount do
  begin
    if(not(FindTextTpa(1158880, 9, 167, 146, 352, 161, Tool, SmallChars, Nothing)))then
    begin
      Mouse((375 + 397) div 2, (147 + 163) div 2, 1, 1, True);
      Wait(RandomRange(250, 750))
    end else
      Break;
  end;

  Result := itemSlotFilled;

  Wait(RandomRange(250, 750));
  MouseBox(479, 20, 491, 29, mouse_Left);
end;

(*
GetMusic
~~~~~~~~

.. code-block:: pascal

    function GetMusic: string;

Gets the music that's currently playing.

.. note::

    by Nielsie95 and ZephyrsFury

Example:

.. code-block:: pascal

*)
function GetMusic: string;
var
  Pts: TPointArray;
  B: TBox;
begin
  if (GetCurrentTab <> tab_Music) then
  begin
    GameTab(tab_Music);
    Wait(500 + Random(500));
  end;
  if (FindColorsTolerance(Pts, 39401, 553, 242, 729, 264, 0)) then
  begin
    B := GetTPABounds(Pts);
    Result := Trim(GetTextAtEx(B.X1 - 1, 245, 0, UpCharsEx, False, False, 0, 1, 39401, 50, False, tr_AllChars));
  end;
end;

(*
CloseAllScreens
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function CloseAllScreens: boolean;

Close BankScreen, DepositScreen, ShopScreen, ToolBeltScreen and the PinScreen.
Returns true if any of them is closed.

.. note::

    by Tickyy

Example:

.. code-block:: pascal

    CloseAllScreens();

*)
function PinScreen: boolean; forward;
function CloseAllScreens: boolean;
var
  I: Integer;
begin
  for I := 0 to 4 do
  begin
    case I of
      0: Result := BankScreen;
      1: Result := DepositScreen;
      2: Result := ShopScreen;
      3: Result := ToolBeltScreen;
      4: Result := PinScreen;
    end;

    if Result then
      if CloseWindow then
      begin
        Result := true;
        Exit;
      end else
        Result := false;
  end;
end;
